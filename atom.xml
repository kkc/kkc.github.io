<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kakashi&#39;s Notes</title>
  <icon>https://www.gravatar.com/avatar/a78f6cc4fc127a344343983280674d46</icon>
  <subtitle>修其本而末自應</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kkc.github.io/"/>
  <updated>2018-09-09T12:44:49.477Z</updated>
  <id>http://kkc.github.io/</id>
  
  <author>
    <name>Kakashi</name>
    <email>kakashi1000@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Build a better client</title>
    <link href="http://kkc.github.io/2018/08/26/build-a-better-client/"/>
    <id>http://kkc.github.io/2018/08/26/build-a-better-client/</id>
    <published>2018-08-26T12:36:29.000Z</published>
    <updated>2018-09-09T12:44:49.477Z</updated>
    
    <content type="html"><![CDATA[<div style="text-align:center"><br><iframe src="//www.slideshare.net/slideshow/embed_code/key/pF9d6lGQKScGHc" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/kakashiliu/build-a-better-client-111628081" title="Build a better client" target="_blank">Build a better client</a> </strong> from <strong><a href="https://www.slideshare.net/kakashiliu" target="_blank">cc liu</a></strong> </div><br></div><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>This is a talk I presented at the internal company meeting. It mainly addresses how could we create better client behavior for modern software architecutre. We all know that microservices becomes more and more popular nowadays. Everybody notices about the benefit of microservices that each team can do development, deployment, and service scaling independently. It also makes each component becomes more understandable and maintainable. However, decomposing an application into different services introduces the reliability problems. Because these services usually are connected to each other by the computer network instead of in the single machine, we need to be more careful to handle network errors and service errors.</p><h1 id="Fallacies-of-distributed-computing"><a href="#Fallacies-of-distributed-computing" class="headerlink" title="Fallacies of distributed computing"></a>Fallacies of distributed computing</h1><p>According to the <a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" target="_blank" rel="noopener">wiki</a>, there are 8 fallacies of distributed computing. I think everyone design a system connected by networking should get familiar with this knowledge. It’s so important to understand that the computer network is not reliable and that’s the reason why we have TCP protocol. Even though TCP does lots of thing for us, we still need to take care of the effect of these fallacies.</p><ol><li>The network is reliable.</li><li>Latency is zero.</li><li>Bandwidth is infinite.</li><li>The network is secure.</li><li>Topology doesn’t change.</li><li>There is one administrator.</li><li>Transport cost is zero.</li><li>The network is homogeneous.</li></ol><h1 id="7-resilience-policies"><a href="#7-resilience-policies" class="headerlink" title="7 resilience policies"></a>7 resilience policies</h1><p>I suggest everyone can adopt these resilience policies for improving the client-side program.<br>Actually, each policy can be a big topic, here I only provide some notes.</p><h2 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h2><p>Basically we use retry to overcome transient failures which might be server side errors or networking errors.<br>Here I found out the awesome <a href="http://allyouneedisbackend.com/blog/2017/09/15/how-backend-software-should-retry-on-failures/" target="_blank" rel="noopener">article</a> to address different scenarios that we should take care of.</p><ul><li>DNS error</li><li>Connection error</li><li>Timeout</li></ul><p>If it’s an application error, we can perform retrying based on following status code.</p><ul><li>503 (Service unavailable)</li><li>429 (too many requests)</li><li>408 (request timeout)</li><li>500 (Internal server error)</li></ul><p>It’s also important to know if this call is idempotent so that retrying won’t cause data duplication and other side effects.<br>In addition, if server returns 400, you should probably fix your data instead of performing the retry.</p><h2 id="Retry-Back-off-jitter"><a href="#Retry-Back-off-jitter" class="headerlink" title="Retry + Back off + jitter"></a>Retry + Back off + jitter</h2><p>Although the retry mechanism makes client become more resilient, it also can hurt the server in certain situations. Consider a server is overloading and couldn’t deal with many requests at the same time, repetitive tries will make the situation worse. Back off and jitter can help server recovery from failing.</p><p>According to this <a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">AWS article</a>:</p><p><img src="https://d2908q01vomqb2.cloudfront.net/fc074d501302eb2b93e2554793fcaf50b3bf7291/2017/10/03/exponential-backoff-and-jitter-blog-figure-4.png" alt="backoff"></p><ol><li><p>Adding backoff can slow clients down and reduce wasteful invocations. In addition, Server loading is decreased since the calls occur less and less frequently.</p></li><li><p>Adding jitter can resolve the issue that clusters of calls come to server and make server super busy within the certain time period. Adding randomness delay between each retry can spread out the server loading spikes.</p></li></ol><p><img src="/img/2018-08/jitter.png" alt="backoff"></p><h2 id="Circuit-Breaker"><a href="#Circuit-Breaker" class="headerlink" title="Circuit Breaker"></a>Circuit Breaker</h2><p>The circuit breaker is used between the client and server. When a server doesn’t response certain requests for a while (maybe after multiple retries with given timeout), we can adopt circuit breaker to stop client to call server wastefully.</p><h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><p>Set up the timeout of every invocation properly can save client resources efficiently. Don’t let an invocation without timeout occupied resources forever.</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Use cache to reduce the frequency of calls. It not only shortens latency of invocation but also reduces server-side loading. But don’t forget. There are 2 hard problems in computer science: cache invalidation, naming things. Design a proper cache invalidation is not easy.</p><h2 id="Bulkhead-isolation"><a href="#Bulkhead-isolation" class="headerlink" title="Bulkhead isolation"></a>Bulkhead isolation</h2><p>This is an interesting policy which saperating client resources for different purposes. For example, we can use different thread pools for different services. Once one of the remote server crushed or became abnormal, it won’t affect whole client performance. There is a famous implementation in the Netflix library Hystrix, you can refer to <a href="https://stackoverflow.com/questions/30391809/what-is-bulkhead-pattern-used-by-hystrix" target="_blank" rel="noopener">https://stackoverflow.com/questions/30391809/what-is-bulkhead-pattern-used-by-hystrix</a>.</p><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>Return reasonable responses instead of showing error messages.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Building a better client not only enhances your reliability of client-side application but also improves the stability of whole systems. It’s worth considering to adopt these policies in your client-side program.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a></li><li><a href="http://allyouneedisbackend.com/blog/2017/09/15/how-backend-software-should-retry-on-failures/" target="_blank" rel="noopener">http://allyouneedisbackend.com/blog/2017/09/15/how-backend-software-should-retry-on-failures/</a></li><li><a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/</a></li><li><a href="https://stackoverflow.com/questions/30391809/what-is-bulkhead-pattern-used-by-hystrix" target="_blank" rel="noopener">https://stackoverflow.com/questions/30391809/what-is-bulkhead-pattern-used-by-hystrix</a></li><li><a href="https://dzone.com/articles/performance-patterns-in-microservices-based-integr-1" target="_blank" rel="noopener">https://dzone.com/articles/performance-patterns-in-microservices-based-integr-1</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/pF9d6lGQKScGHc&quot; width=&quot;595&quot; height=&quot;485&quot; frame
      
    
    </summary>
    
    
      <category term="distributed-system" scheme="http://kkc.github.io/tags/distributed-system/"/>
    
  </entry>
  
  <entry>
    <title>記一次 Elasticsearch troubleshooting 的歷程</title>
    <link href="http://kkc.github.io/2018/08/15/lesson-learn-of-elasticsearch-outage/"/>
    <id>http://kkc.github.io/2018/08/15/lesson-learn-of-elasticsearch-outage/</id>
    <published>2018-08-15T14:57:44.000Z</published>
    <updated>2018-09-09T12:44:49.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="過程"><a href="# 過程" class="headerlink" title="過程"></a>過程 </h2><p> 前陣子又發生了 AWS Elasticsearch 的 status 變成 red 的情況，這次跟以往的情形有點不一樣，之前爆炸都是因為 disk space 不足，而後來增加了 Curator 定期清理資料後就解了，而這次發生的 outage 有點不同，也讓我想要記錄下發生的原因和解法。</p><h2 id="調查"><a href="# 調查" class="headerlink" title="調查"></a>調查 </h2><p> 在開了 Support ticket 和查詢 AWS 的 document 後，初步有了一些方向，根據文件上面寫的 A red cluster status means that at least one primary shard and its replicas are not allocated to a node，其實就是跟 shard 是不是運作正常有關係，這邊更新一些 Elasticsearch 的科普知識，Elasticsearch 的 document 其實是放在 index 裡面，而 index 會根據你設定的 shard 數量，把 document 平均分散到不同 shard 中，然後把不同的 shard 放在不同的 node 中，以求可以分散式的去請求資料，而在沒有調整過的 AWS elasticsearch 中預設的 shard 數量是 5，所以每次 create 一個新的 index 就會產生 5 個 shard，經過 AWS support 的調查，我們家的 elasticsearch 裡面共有 10654 shard (抖)，而太多的 shard 接著就造成 CPU utilization 越來越重，最後重到某個 node 存取不到後 (猜想該 node 應該是炸掉了)，某個 shard 又沒有即時產生好 replica 存在另外一個 node 上，就這樣 status red recovery 失敗。</p><h2 id="Troubleshooting- 技巧"><a href="#Troubleshooting- 技巧" class="headerlink" title="Troubleshooting 技巧"></a>Troubleshooting 技巧</h2><ol><li>使用 <code>GET /_cluster/allocation/explain</code> 可以看到 cluster 裡面哪些 assigned shard 出問題，還有原因是什麼</li><li>使用 <code>GET /_cat/indices?v</code> 可以看到哪些 index 是有問題的</li></ol><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">health status index            uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">green  open   test1            <span class="number">30</span>h1EiMvS5uAFr2t5CEVoQ   <span class="number">5</span>   <span class="number">0</span>        <span class="number">820</span>            <span class="number">0</span>       <span class="number">14</span>mb           <span class="number">14</span>mb</span><br><span class="line">green  open   test2            sdIxs_WDT56afFGu5KPbFQ   <span class="number">1</span>   <span class="number">0</span>          <span class="number">0</span>            <span class="number">0</span>       <span class="number">233</span>b           <span class="number">233</span>b</span><br><span class="line">green  open   test3            GGRZp_TBRZuSaZpAGk2pmw   <span class="number">1</span>   <span class="number">1</span>          <span class="number">2</span>            <span class="number">0</span>     <span class="number">14.7</span>kb          <span class="number">7.3</span>kb</span><br><span class="line">red    open   test4            BJxfAErbTtu5HBjIXJV_7A   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line">green  open   test5            _8C6MIXOSxCqVYicH3jsEA   <span class="number">1</span>   <span class="number">0</span>          <span class="number">7</span>            <span class="number">0</span>     <span class="number">24.3</span>kb         <span class="number">24.3</span>kb</span><br></pre></td></tr></table></figure><ol start="3"><li><code>cannot allocate because a previous copy of the primary shard existed but can no longer be found on the nodes in the cluster</code> 基本上我們家遇到這個訊息在講的就是 primary shard 跟著 node 失蹤了，如果該 node 沒有回來，而你的資料很重要，可能就要從 snapshot 裡面撈回來</li></ol><h2 id="解決方法"><a href="# 解決方法" class="headerlink" title="解決方法"></a>解決方法 </h2><p> 我們基本上爛掉的 elasticsearch 是拿來存 application log 的，所以該 index 壞掉其實不太會影響線上資料，而按照 AWS support 的教學和查詢的一些文章，我們的解法如下</p><ol><li>砍掉該壞掉的 index ，<code>curl -XDELETE &lt;cluster&gt;/&lt;index_name&gt;</code></li><li>砍掉 older/unused/smaller 的 index 減少 cluster loading</li><li>更改設定減少每個 index 的 shard 的數量</li></ol><p>其他學習到的東西</p><ol><li>根據需求，可以使用 dedicated master node 增加系統的 stability</li><li>越少的 shard 系統會越穩定，10 shards gives great performance, 100 gives good performance, 500 gives okay performance, 1000 gives bad performance and over 2000 is when the cluster begins to become unstable.</li><li>還有讓 shard 的 size 保持在 10GB~50GB 的大小，會讓 query 的 performance 比較好</li><li>以下的兩篇 reference 有講到很多其他 troubleshooting 的技巧</li></ol><p>Reference<br><a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-handling-errors.html#aes-handling-errors-red-cluster-status" target="_blank" rel="noopener">https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-handling-errors.html#aes-handling-errors-red-cluster-status</a><br><a href="https://www.elastic.co/blog/red-elasticsearch-cluster-panic-no-longer" target="_blank" rel="noopener">https://www.elastic.co/blog/red-elasticsearch-cluster-panic-no-longer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;過程&quot;&gt;&lt;a href=&quot;# 過程&quot; class=&quot;headerlink&quot; title=&quot;過程&quot;&gt;&lt;/a&gt;過程 &lt;/h2&gt;&lt;p&gt; 前陣子又發生了 AWS Elasticsearch 的 status 變成 red 的情況，這次跟以往的情形有點不一樣，之前爆炸都是因
      
    
    </summary>
    
    
      <category term="elasticsearch" scheme="http://kkc.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Compassionate code</title>
    <link href="http://kkc.github.io/2018/07/24/thoughts-on-compassionate-code/"/>
    <id>http://kkc.github.io/2018/07/24/thoughts-on-compassionate-code/</id>
    <published>2018-07-24T01:46:28.000Z</published>
    <updated>2018-09-09T12:44:49.476Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2018-07/compassionate.jpg" alt="compassionate.jpg"></p><p> 這是一篇感想文，最近看完了一篇文章叫做 <a href="http://johannesbrodwall.com/2018/06/24/forget-about-clean-code-lets-embrace-compassionate-code/" target="_blank" rel="noopener">Forget Clean Code, let’s embrace Compassionate Code</a>，還有一篇相關的文章 <a href="http://blog.markpearl.co.za/Thoughts-on-Compassionate-Code" target="_blank" rel="noopener">Thoughts-on-Compassionate-Code</a>，這裡寫的是對第一篇文章的感想，然後在第二篇的文章中找到了一些相同的感觸。</p><p> 從 Johannes 寫的 embrace compassionate code 中，談到他對於 clean code 的一些衝突，他原先是 clean code 的信徒，在他早期的職涯生活中，常常加班幫同事修正那些有 bad smell 的 code，但最後發現有時候這樣做，在沒有取得 psychology safety 的情況下，反而讓工作的氣氛變得更糟，而提出了 compassionate code ，把注意力拉回到人的本身，有些人不是不想寫 clean code ，而是每個人的生活有不同的 priority，有可能是趕 project deadline 或是修改一些 legacy code 讓系統可以動，而不想花太多時間改動程式碼，然後目的也許是早點下班為了家人小孩或是其他的興趣。</p><p> 其實文章裡面有些部分，感覺是 Johannes 對於 Uncle Bob 有一些不滿，因為 Uncle Bob 對於不遵守教條的人，似乎是用不近人情的方式批評，而 Johannes 也被冠上是 against clean code 的人，這也使得這篇文章變得有點攻擊性，但文章的核心其實很簡單，Software development 應該要回歸到人的本身，而不要為了程式碼而導致很多團隊摩擦。</p><p> 我最近也在省思，怎麼樣的工作環境和文化才會讓人有 psychology safety，回歸到人後，讓每個人都可以講出心裡話，而不是在背後抱怨或是 murmur ，也許才能使得團隊變成 self-organized， 因為每個人加入團隊的原因不同，還有對於工作和品質要求也不一樣，單純讓 programmer 遵守一堆 rules，而不是透過溝通了解 為什麼，有時候真的會造成不少的摩擦 ，這些摩擦其實也變成團隊的阻力，儘管 code 變漂亮了，但是人心卻散了，讓大家不想自動自發地提出建議和改善，這才是真正的傷害了效能。</p><p> 第二篇文章中寫道，Being Non-Judgemental &amp; Discerning 也是給我當頭棒喝，有時候我也在想維持皇城內的和諧 (psychology safety) 雖然很重要，但是否就是無法提出建言了呢，然後無法去提出讓事情變好的方法，文中提到其實提出意見，可以使用更好的方式，也就是不要只是從一個 dimension 做出評論，而是用比較的方式講出不同 dimension 的差別，像是評論兩個歌手的時候，不要只用某歌手唱歌不好聽來做評論，而是從他們的唱腔，會不會作詞作曲，或是一些表演的小細節來做比較，回歸到寫程式做架構這件事情上，其實也就是需要了解對方為什麼或這樣做，也許是不熟悉或是沒經驗，也有可能是為了趕時間的 workaround，之後再去給予建言比較，覺得這樣寫可以避免什麼問題，或是幫忙開張票紀錄以後可以重構這段 code，都是比起直接批評要好上不少。</p><p> 我的想法其實也簡單，很多事情都是有價值的，好的流程，好的程式碼，好的文件，有向心力的組織，好的工作環境，不應該為了其中一項而忘了其他東西，在團隊中互相支持，互相給予回饋，建立好的溝通管道，其實跟寫好程式碼是差不多重要的事情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/2018-07/compassionate.jpg&quot; alt=&quot;compassionate.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt; 這是一篇感想文，最近看完了一篇文章叫做 &lt;a href=&quot;http://johannesbrodwall.com/2018/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gracefully Shutdown Docker Container</title>
    <link href="http://kkc.github.io/2018/06/06/gracefully-shutdown-docker-container/"/>
    <id>http://kkc.github.io/2018/06/06/gracefully-shutdown-docker-container/</id>
    <published>2018-06-06T15:26:34.000Z</published>
    <updated>2018-09-09T12:44:49.476Z</updated>
    
    <content type="html"><![CDATA[<p>Recently, I have been working on some existing projects trying to implement graceful shutdown mechanism. The initial idea is to make application invokes deconstructor of each component as soon as the application receives specific signals such as <code>SIGTERM</code> and <code>SIGINT</code>.  The idea works really well when I ran the application natively on my Macbook pro.  However, by using <code>docker stop</code> and <code>docker kill</code>, it didn’t work as expected - To receives a signal and performs the corresponding cleanup tasks.  So, what is exactly the Docker container shutdown process ?</p><h2 id="Process-behavior-in-Docker"><a href="#Process-behavior-in-Docker" class="headerlink" title="Process behavior in Docker"></a>Process behavior in Docker</h2><p>When you run a docker container, by default it has a PID namespace, which means the docker process is isolated from other processes on your host. A typical PID namespace is a tree structure, and it starts from <code>PID1</code>, which is also called <code>init</code> in the Linux system. The PID namespace has an important task to reap zombie processes. So what is the correspondent of <code>PID1</code> in the docker container? Let’s see some scenarios according to <a href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html" target="_blank" rel="noopener">yelp articles</a>.</p><p>when we use <code>docker run</code>, there are 2 forms:</p><ul><li><code>RUN &lt;command&gt;</code> (<em>shell</em> form)</li><li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (<em>exec</em> form)</li></ul><h3 id="Senario1-shell-form"><a href="#Senario1-shell-form" class="headerlink" title="Senario1:  shell form"></a>Senario1:  shell form</h3><ul><li>docker run  (on the host machine)<ul><li><code>/bin/bash</code> (PID1, inside container)<ul><li><code>python server.py</code> (PID2, inside container)</li></ul></li></ul></li></ul><p>This uses <code>/bin/bash</code> as PID1 and runs your program as the subprocess. There is a problem with this approach - When a signal is sent to a shell, the signal actually won’t be forwarded to subprocesses. This pretty much makes our application broken. Consider situation that there are ongoing requests come to our server, and the data processing by server is still in the memory. If server is terminated without signal notification, tons of requests may fails and processing data might not be written back to the database.</p><h3 id="Senario2-exec-form"><a href="#Senario2-exec-form" class="headerlink" title="Senario2:  exec form"></a>Senario2:  exec form</h3><ul><li>docker run  (on the host machine)<ul><li><code>python server.py</code> (PID1, inside container)</li></ul></li></ul><p>By using the exec form, we can run our program as <code>PID1</code>. This method is much better than Senario1 because we can directly handle the signal in the application. But if you use exec form to run a shell script to spawn your application, remember to use <em>exec</em> syscall to overwrite <code>/usr/bin/bash</code> otherwise it will act as senario1.</p><p>instead of</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="meta-keyword">/usr/</span>bin/bash</span><br><span class="line">python <span class="meta-keyword">/app/</span>server.app</span><br></pre></td></tr></table></figure><p>do</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="meta-keyword">/usr/</span>bin/bash</span><br><span class="line">exec python <span class="meta-keyword">/app/</span>server.app</span><br></pre></td></tr></table></figure><p>Using exec form seems pretty good to us, but it leads to another problem, which is zombie process handling. Although the best practice is to create the program properly without generating zombie process. I often see zombie process generated in a program. It’s really hard to detect zombies process because zombies process may be generated by other frameworks or libraries. I need to mention In senario1, <code>/bin/bash</code> can handle repeating zombie process. So inevitably, we need to think if there are other better solutions.</p><h2 id="Tini-for-the-rescue"><a href="#Tini-for-the-rescue" class="headerlink" title="Tini for the rescue"></a>Tini for the rescue</h2><p><a href="https://github.com/krallin/tini" target="_blank" rel="noopener">https://github.com/krallin/tini</a> is a special project aiming to tackle this problem. According to README file, benefics of Using Tini are:</p><ul><li>It protects you from software that accidentally creates zombie processes, which can (over time!) starve your entire system for PIDs (and make it unusable).</li><li>It ensures that the <em>default signal handlers</em> work for the software you run in your Docker image. For example, with Tini, <code>SIGTERM</code> properly terminates your process even if you didn’t explicitly install a signal handler for it.</li></ul><p>We can simply run <code>tini</code> as PID1 and it will forward the signal for subprocesses. Typically, tini is a signal proxy and it also can deal with zombie process issue automatically. After <em>Docker 1.13</em>  or greater version, you can run your program with tini by passing <code>--init</code> flag to <code>docker run</code> .</p><p>Worth to mention that the other similar project is dump-init by Yelp. A python package that can be installed from Pypi.</p><h2 id="Gracefully-Shutdown"><a href="#Gracefully-Shutdown" class="headerlink" title="Gracefully Shutdown"></a>Gracefully Shutdown</h2><p>Let us take a look at 2 docker command related to shutdown container</p><h3 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a>docker stop</h3><p>when we use <code>docker stop</code>, docker will wait for 10s for stopping container before killing a process (by default). The main process inside the container will receive <code>SIGTERM</code>, then docker daemon will wait for 10s and send <code>SIGKILL</code> to terminate process.</p><h3 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h3><p>kill running containers immediately. it’s more like <code>kill -9</code> and <code>kill --SIGKILL</code>.</p><p><code>docker stop</code> is what we rather use. It makes container perform a cleanup task after receiving <code>SIGTERM</code> signal.</p><h3 id="shutdownTimeout-and-stopTimeout"><a href="#shutdownTimeout-and-stopTimeout" class="headerlink" title="shutdownTimeout and stopTimeout"></a>shutdownTimeout and stopTimeout</h3><p>Knowing timeout is also important for us to implement gracefully shutdown. We need to set up a reasonable timeout for containers to clean up the task. The default time can be configured both on daemon and per containers.</p><p><code>shutdownTimeout</code> : docker deamon</p><p><code>stopTimeout</code>: docker container</p><p>When docker daemon receives <code>SIGTERM</code> , it will send the <code>SIGTERM</code> to all containers. The longest timeout will be applied.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>Use exec form to run your program</li><li>Use exec in your shell script</li><li>Realize what’s PID1 in your docker container</li><li>Set up a reasonable timeout of docker daemon config</li><li>Leverage <code>docker run --init</code></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/" target="_blank" rel="noopener">https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/</a><br><a href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html" target="_blank" rel="noopener">https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html</a><br><a href="https://hynek.me/articles/docker-signals/" target="_blank" rel="noopener">https://hynek.me/articles/docker-signals/</a><br><a href="https://github.com/moby/moby/pull/34992/files" target="_blank" rel="noopener">https://github.com/moby/moby/pull/34992/files</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Recently, I have been working on some existing projects trying to implement graceful shutdown mechanism. The initial idea is to make appl
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kkc.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>用 docker 改善開發流程筆記</title>
    <link href="http://kkc.github.io/2018/04/28/docker-note/"/>
    <id>http://kkc.github.io/2018/04/28/docker-note/</id>
    <published>2018-04-27T16:05:18.000Z</published>
    <updated>2018-09-09T12:44:49.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h1><p> 在接觸 docker 的這三年中，從一開始的好奇和迷惘，到後來接受並享受了它的好處，途中經歷了一些不為人知的小困難，最近想寫這篇文慢慢回味並且分享一下我的 docker 學習心得，又因為我在 development + operation 方面的工作都有涉獵，更讓我對使用 docker 有不同的體會。</p><p>加入目前的公司 <a href="https://umbocv.ai/" target="_blank" rel="noopener">Umbo CV</a> 兩年多來，對於裡面的大小夥伴們能夠一起接受並學習 docker 作為開發環境，並且部署到 production 系統，現在回想起來，著實讓人感到興奮，畢竟在當時，使用 docker 並且跑在 production 上面的公司，少之又少，即使到了現在，也是有些公司尚未 dockerize 他們重要的 components，而我們在當時就毅然決然的全面採用 docker，真的是一項不錯的投資。</p><h1 id="Docker- 解決了什麼呢"><a href="#Docker- 解決了什麼呢" class="headerlink" title="Docker 解決了什麼呢?"></a>Docker 解決了什麼呢?</h1><p>這個問題讓我回想到大學時期當網管的時候，那時有一個很重要的任務，叫做電腦教室系統還原，印象深刻的是，我採用的高科技玩意叫做 Ghost，而把硬碟 mirror 後就會產生一個文件，我們稱它為映像檔 (image)，最棒的地方在於，不管你在哪台電腦上面用這個 image 做還原，他就會跟原本的製作的環境一模一樣，這帶來的好處很明顯，就是我們只要透過網路，而不需要一台一台電腦用磁片重新安裝就能使他們回復到一樣的狀態。</p><p>回過頭來講到執行環境，不管對於使用者或是開發者來說，都是一個很困擾的問題，同樣的程式在不同的 OS, libarary 下面執行，總是會有不同的執行結果和產生不同的臭蟲。舉個例子，在我的大學期末專題中，常常遇到不同人開發的程式，在其他人的電腦上面執行不了的問題，最慘的就是沒辦法在助教的電腦上面執行，而在當時筆記型電腦不盛行的時代，還需要人肉到助教的實驗室，借用電腦把程式修好。</p><p>再來到了雲端時代，在 AWS/Azure/GCP 上面有很方便的方法，幫忙你把既有的 VM 打成 image，可以很快地在不同的 instance type 上面做還原，然後個人電腦也有像是 virtualbox, vmware 加上 vagrant 去模擬不同的環境，打包好的 image 還有 config 也可以跟其他人互通有無，其實已經比以前方便非常多了!</p><p>而 docker 的橫空出世又是一個非常重要的里程碑，傳統的 VM solution 雖然是好棒棒，但是速度和體積來說真的是太大太肥，而開機的時間不管再怎麼壓縮，最快還是需要個 3~5 分鐘，當然這是相對 docker 而言，要不然 VM 已經是稱霸了好一陣子。 另外 docker 的出現真的是消弭了 development 和 operation 之間的環境差距，就像之前講的 developer 的環境有可能是自己安裝，或是使用 virtualbox 之類的工具，然後用 bash script/Makefile 或是寫進 Readme 文件裡面紀錄怎麼安裝，而負責 operation 的人也必須要花時間，看能不能成功裝在 AWS/Azure/GCP 這些 cloud provider 的 VM 上，這些工作常常需要耐心和時間，也常常因為版本的不同，導致 program 有不一樣的 behavior。</p><p><img src="/img/2018-04/say-it-works-on-my-computer-one-more-time.jpg" alt="say-it-works-on-my-computer-one-more-time.jpg"></p><h1 id="Docker-vs-VM"><a href="#Docker-vs-VM" class="headerlink" title="Docker vs VM"></a>Docker vs VM</h1><p><img src="/img/2018-04/docker.png" alt="docker.png"></p><p>這張圖來自 docker <a href="https://docs.docker.com/v17.09/get-started/" target="_blank" rel="noopener">官網</a>，基本上 Docker 會比 VM 輕量的原因就是因為少了一層 Guest OS，尤其在跑很多的 docker container 時，就少了 N 層的 Guest OS。</p><h1 id="Basic-Terminology"><a href="#Basic-Terminology" class="headerlink" title="Basic Terminology"></a>Basic Terminology</h1><p>首先先看一下這張來自 docker 官網的圖，簡單闡述了 docker components 之間的關係。</p><p><img src="img/2018-04/image-20180425223501866.png" alt="structure"></p><ul><li>Imgaes: 是一個 read-only 的 template，其中包含了需要的 library &amp; application，而當 containers 被執行起來的時候，這些 read-only 的 layers 會被共用。</li><li>Container: 可以視為從 image 產生出來的 instance，而每個容器都有自己的 lifecycle，從出生到死亡每個 container 之間是互相隔離的。而有趣的是 image 是 read-only 的，但是 container 卻會在上面多加一層 writalbe 的 layer。</li><li>Registry: 擺放 docker image 的倉庫。</li><li>Dockerfile: 用來記錄構建 image 的 instructions。 (上面這張圖沒畫出來)</li></ul><h2 id="基本指令"><a href="# 基本指令" class="headerlink" title="基本指令"></a>基本指令 </h2><p> 這邊只會做個簡單紀錄，很多網路上的文章都有詳細介紹惹！</p><ol><li>建構 docker image: <code>docker build --tag hello -f Dockerfile .</code></li><li>列出 docker images: <code>docker images</code></li><li>利用 docker image 去產生 <code>docker container: docker run hello</code></li><li>將 image 推到 docker registry: <code>docker push hello</code></li><li>將 image 從 docker registry 下載: <code>docker pull hello</code></li></ol><h1 id="建構 -docker-image-w-Dockerfile"><a href="# 建構 -docker-image-w-Dockerfile" class="headerlink" title="建構 docker image w/ Dockerfile"></a>建構 docker image w/ Dockerfile</h1><p>dockerfile 是拿來建構 image 的 file，而最基本的 Dockerfile 可以寫成下面這樣</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /hello /</span></span><br><span class="line"><span class="bash">RUN cat /hello</span></span><br></pre></td></tr></table></figure><p>然後使用指令 <code>docker build -t hello:v1 -f Dockerfile .</code> 來建構我們的 image</p><h2 id="build-context"><a href="#build-context" class="headerlink" title="build context"></a>build context</h2><p>build context 的概念也是需要知道的一件事，會加速我們建構 docker image 的時間，而 context 可以是本地端的目錄或是遠端的 URL，而 docker 在 build stage 時，其實是把 context 傳進 docker daemon，然後透過 docker daemon 來 build image，而上面的指令可以視為 <code>docker build -t hello:v1 -f Dockerfile context</code>。</p><p>我們可以使用 <code>.dockerignore</code> 去定義哪些檔案不需要傳入 docker daemon，基本上在 build 時，會看到一個訊息像是 <code>Sending build context to Docker daemon  142.5MB</code> 就可以知道 build context 有多大。</p><h2 id="multistage-build"><a href="#multistage-build" class="headerlink" title="multistage build"></a>multistage build</h2><p>在 Docker 17.05 後，就可以使用 multistage build 去減少 docker image 的大小，以往我們因為要建構不同需求的 image 需要準備不同的 Dockerfile，像是</p><ul><li>有安裝 Build tool chain 的 docker image</li><li><p>專門跑 production application 的 image</p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---- Build ----</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3</span> as build</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt .</span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="bash"><span class="comment">#---- Test ----</span></span></span><br><span class="line"><span class="bash"><span class="comment">## run test</span></span></span><br><span class="line"><span class="bash">FROM build as <span class="built_in">test</span></span></span><br><span class="line"><span class="bash">RUN pip install pylint &amp;&amp; \</span></span><br><span class="line"><span class="bash">    pip install pytest</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="bash"><span class="comment">#---- Release ----</span></span></span><br><span class="line"><span class="bash">FROM python:3-alpine</span></span><br><span class="line"><span class="bash">COPY --from=build /root/.cache /root/.cache</span></span><br><span class="line"><span class="bash">COPY --from=build requirements.txt .</span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt &amp;&amp; rm -rf /root/.cache</span></span><br></pre></td></tr></table></figure></li></ul><p>而有了 multi-stage build 就可以利用一個 Dockerfile build 出不同 stage 的 image，例如</p><p><code>docker build --target build -t builder-stage -f Dockerfile .</code><br><code>docker build --target test -t test -f Dockerfile .</code><br><code>docker build -t release -f Dockerfile .</code></p><p>然後可以看到最後要 release 的版本，我們是利用 alpine，足足可以省下好幾百 mb 的空間。</p><h2 id="Optimization-amp-amp-Debugging-skill"><a href="#Optimization-amp-amp-Debugging-skill" class="headerlink" title="Optimization &amp;&amp; Debugging skill"></a>Optimization &amp;&amp; Debugging skill</h2><p>docker image 最佳化的部分，不免是減少 layer，將一些垃圾砍掉，但是有了 multistage build 之後，其實改善的空間更大，而很多其實參考 <a href="https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener"> 官網文件 </a> 也有寫到。</p><p>Debugging skill 的部分，我想很值得一提，以往我們常常在 build image 的時候，可能會有一些 package conflict 或是有些 library 裝不起來，但是一直使用 docker build 試誤也是很煩人的事情，舉個例子，如果上面的那個範例不小心打成</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#---- Test ----</span></span><br><span class="line"><span class="comment">## run test</span></span><br><span class="line"><span class="keyword">FROM</span> build as test</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install pylint</span></span><br><span class="line"><span class="bash">    pip install pytest</span></span><br></pre></td></tr></table></figure><p>少了 &amp;&amp; \ 會看到下列錯誤訊息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon   2.56kB</span><br><span class="line">Step 1/10 : FROM python:3 as build</span><br><span class="line"> <span class="comment">---&gt; 6bf7a4fa2d45</span></span><br><span class="line">Step 2/10 : LABEL builder=true</span><br><span class="line"> <span class="comment">---&gt; Using cache</span></span><br><span class="line"> <span class="comment">---&gt; 472d4ae6ffaa</span></span><br><span class="line">Step 3/10 : COPY requirements.txt .</span><br><span class="line"> <span class="comment">---&gt; Using cache</span></span><br><span class="line"> <span class="comment">---&gt; ba0558adfb4d</span></span><br><span class="line">Step 4/10 : RUN pip <span class="keyword">install</span> -r requirements.txt</span><br><span class="line"> <span class="comment">---&gt; Using cache</span></span><br><span class="line"> <span class="comment">---&gt; 9b432c1c82e4</span></span><br><span class="line">Step <span class="number">5</span>/<span class="number">10</span> : <span class="keyword">FROM</span> <span class="keyword">build</span> <span class="keyword">as</span> <span class="keyword">test</span></span><br><span class="line"> <span class="comment">---&gt; 9b432c1c82e4</span></span><br><span class="line">Step <span class="number">6</span>/<span class="number">10</span> : RUN pip <span class="keyword">install</span> pylint      pip <span class="keyword">install</span> pytest</span><br><span class="line"> <span class="comment">---&gt; Running in 01fde55c23d9</span></span><br><span class="line">Collecting pylint</span><br><span class="line">  Downloading https://files.pythonhosted.org/packages/<span class="number">8</span>b/<span class="number">62</span>/b2c07085dd7bb4b7e8bb813873421692c1157191e87234550a1c39dff232/pylint<span class="number">-1.8</span><span class="number">.4</span>-py2.py3-<span class="keyword">none</span>-any.whl (<span class="number">690</span>kB)</span><br><span class="line">Requirement already satisfied: pip <span class="keyword">in</span> /usr/<span class="keyword">local</span>/lib/python3<span class="number">.6</span>/site-packages (<span class="number">10.0</span><span class="number">.1</span>)</span><br><span class="line">Collecting <span class="keyword">install</span></span><br><span class="line">  Could <span class="keyword">not</span> find a <span class="keyword">version</span> that satisfies the requirement <span class="keyword">install</span> (<span class="keyword">from</span> <span class="keyword">versions</span>: )</span><br><span class="line"><span class="keyword">No</span> matching distribution <span class="keyword">found</span> <span class="keyword">for</span> <span class="keyword">install</span></span><br><span class="line">The command <span class="string">'/bin/sh -c pip install pylint      pip install pytest'</span> returned a non-zero code: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>這時候其實可以使用指令 <code>docker run -ti --rm 9b432c1c82e4 bash</code> 登入 intermediate layer 來 debug，這個技巧在實務上面蠻需要的。</p><h1 id="Development-environment-revolution"><a href="#Development-environment-revolution" class="headerlink" title="Development environment revolution"></a>Development environment revolution</h1><p>重朔 Development environment ，我認為是 docker 對 developer 來說最大的改變，就如我之前講的 developer 寫好的 code ，常常離實際的 production 環境有段距離，更別說現在有些採用 microservice 架構的應用，更是難以在本機建構一模一樣的環境做測試，以下會介紹一下我們 project 的 layout，加上如何採用 docker 來建構開發環境。</p><p>以下是 project layout，可以看到我們會擺放 <code>Dockerfile</code>，還有會放一個 <code>enter_dev_env.sh</code> 的 bash script 以供 developer 快速啟動 docker 的開發環境。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── README.md</span><br><span class="line">├── app</span><br><span class="line">│   └── main.py</span><br><span class="line">├── enter_dev_env.sh</span><br><span class="line">└── requirements.txt</span><br></pre></td></tr></table></figure><p>enter_dev_env.sh 的內容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -xe</span></span><br><span class="line"><span class="attribute">CONTAINER</span>=<span class="string">"<span class="variable">$&#123;USER&#125;</span>_application_container"</span></span><br><span class="line"><span class="attribute">START_SHELL</span>=<span class="string">"/bin/bash"</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">BASE_IMAGE</span>=python:3.6-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># test if the container is running</span></span><br><span class="line"><span class="attribute">HASH</span>=`docker ps -q -f <span class="attribute">name</span>=<span class="variable">$CONTAINER</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># test if the container is stopped</span></span><br><span class="line"><span class="attribute">HASH_STOPPED</span>=`docker ps -qa -f <span class="attribute">name</span>=<span class="variable">$CONTAINER</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [-n <span class="string">"<span class="variable">$HASH</span>"</span> ];then</span><br><span class="line">    echo <span class="string">"founding existing running container <span class="variable">$CONTAINER</span>, proceed to exec another shell"</span></span><br><span class="line">    docker exec -it <span class="variable">$HASH</span> <span class="variable">$START_SHELL</span></span><br><span class="line">elif [-n <span class="string">"<span class="variable">$HASH_STOPPED</span>"</span> ];then</span><br><span class="line">    echo <span class="string">"founding existing stopped container <span class="variable">$CONTAINER</span>, proceed to start"</span></span><br><span class="line">    docker start --attach -i <span class="variable">$HASH_STOPPED</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">"existing container not found, createing a new one, named <span class="variable">$CONTAINER</span>"</span></span><br><span class="line">    docker pull <span class="variable">$BASE_IMAGE</span></span><br><span class="line">    docker <span class="builtin-name">run</span> <span class="attribute">--name</span>=<span class="variable">$CONTAINER</span> <span class="attribute">--hostname</span>=<span class="variable">$CONTAINER</span> -ti \</span><br><span class="line">        -v ~/.aws:/root/.aws:ro -v ~/.ssh:/root/.ssh:ro \</span><br><span class="line">        -v <span class="variable">$PWD</span>:/app -w /app <span class="attribute">--entrypoint</span>=<span class="variable">$START_SHELL</span> <span class="variable">$BASE_IMAGE</span></span><br><span class="line">fi</span><br><span class="line">echo <span class="string">"see you, use'docker rm <span class="variable">$CONTAINER</span>'to kill the vm if you want a fresh env next time"</span></span><br></pre></td></tr></table></figure><p>通過這個 file 可以讓全部的開發者，擁有一樣的開發環境，也可以自行修改 <code>$BASE_IMAGE</code> 使用不同的版本和自己建構的 base image，也可以中途離開 container 後，使用同樣這個 script 在登入，接著接續上次的工作。然後</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=<span class="variable">$CONTAINER</span> --hostname=<span class="variable">$CONTAINER</span> -ti \</span><br><span class="line">        -v ~/<span class="selector-class">.aws</span>:/root/<span class="selector-class">.aws</span>:ro -v ~/<span class="selector-class">.ssh</span>:/root/<span class="selector-class">.ssh</span>:ro \</span><br><span class="line">        -v <span class="variable">$PWD</span>:/app -w /app --entrypoint=<span class="variable">$START_SHELL</span> <span class="variable">$BASE_IMAGE</span></span><br></pre></td></tr></table></figure><p>這段是將 base image 跑起來的指令，這邊大家可以自行調整，除了 application 的目錄外，我還習慣把 aws &amp; ssh key 給掛進去以方便開發。</p><h1 id="待續"><a href="# 待續" class="headerlink" title="待續"></a>待續 </h1><p> 這篇文章打到這邊也有點手軟惹，接下來如果有機會，想要把如何使用 docker-compose 做 integration test ，還有搭配 Jenkinsfile 的部署流程分享一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;# 前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言 &lt;/h1&gt;&lt;p&gt; 在接觸 docker 的這三年中，從一開始的好奇和迷惘，到後來接受並享受了它的好處，途中經歷了一些不為人知的小困難，最近想寫這篇文慢慢
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kkc.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>IPSec 筆記</title>
    <link href="http://kkc.github.io/2018/03/21/IPSEC-note/"/>
    <id>http://kkc.github.io/2018/03/21/IPSEC-note/</id>
    <published>2018-03-21T12:49:34.000Z</published>
    <updated>2018-09-09T12:44:49.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h1><p> 這篇筆記是用來記錄 IPSec protocal 的一些細節，前陣子在架設 AWS VPN 的時候，遇到了一些小問題，主要還是防火牆擋到需要走的 port ，而當時就在想自己對於 IPSec protocal 也太不熟悉了，所以才有這篇文章來稍微紀錄一下。</p><h1 id="為什麼需要 -IPSec"><a href="# 為什麼需要 -IPSec" class="headerlink" title="為什麼需要 IPSec"></a>為什麼需要 IPSec</h1><p>IP is not secure，我想這點學過計算機網路的同學應該都會知道這點，而有可能受到以下的風險</p><ul><li><a href="https://en.wikipedia.org/wiki/IP_address_spoofing" target="_blank" rel="noopener">source spoofing</a></li><li><a href="https://en.wikipedia.org/wiki/Replay_attack" target="_blank" rel="noopener">replay packets</a></li><li>data integrity (資料受到竄改)</li></ul><p>基本上使用 VPN 走 IPSec protocal 可以確保 CIA (似乎跟資安有關的都會提到這三個詞）</p><ul><li>Confidentiality: 利用演算法將資料加密 (DES, 3DES, AES &amp; Blowfish)</li><li>Integrity: 資料完整性，利用 hashing algorithm 保證資料沒有受到竄改</li><li>Authentication: 認證</li></ul><h1 id="IPSec-security-architecture"><a href="#IPSec-security-architecture" class="headerlink" title="IPSec security architecture"></a>IPSec security architecture</h1><ul><li>使用 <code>Layer3 Network layer</code> 這層</li><li>Application 層的大家可以無感的享受其 CIA 的好處</li><li>Components<ul><li>Authentication Header (AH)</li><li>Encapsulation Security Payload (ESP)</li><li>Security Associations (SA)</li></ul></li></ul><p>基本上我覺得要懂 IPSec，可以先來弄懂 AH &amp; ESP 會比較重要，因為這兩個東西有對 IP packet 動手腳</p><h2 id="Authentication-Header"><a href="#Authentication-Header" class="headerlink" title="Authentication Header"></a>Authentication Header</h2><p>AH 主要提供的是驗證 Data integrity &amp; data origin source，然後沒有提供任何 <em> 加密 </em> 的功能，使用 HMAC 算法，把 payload &amp; header 和 IKE 定義好的 key 一起拿來 hash，但這邊要小心因為 NAT 會改變 header，而被改變的話，另外一邊就沒辦法解析正確，所以基本上 AH 應該是不可能跟 NAT 共存。<br>而其中又分為 Transport mode &amp; Tunnel mode，後面會有介紹有什麼不同。<br>AH 使用 port 51。</p><p><img src="/img/2018-03/AH.png" alt="AH.png"></p><h2 id="Encapsulation-Security-Payload"><a href="#Encapsulation-Security-Payload" class="headerlink" title="Encapsulation Security Payload"></a>Encapsulation Security Payload</h2><p>ESP 的功能比起 AH 強大了許多，confidentiality, authentication, integrity 都包含在其中了，所以真正有提供加密的功能，而在驗證 Data integrity 方面，還是要看是使用 Transport mode 或是 Tunnel mode</p><ul><li>Transport mode: ESP 沒有對 IP header 做 hash ，所以只能保證 Data 是沒有被修改的</li><li>Tunnel mode: 有將 IP header 包進來，所以這點跟 AH 是一致的</li></ul><p>對照下圖可以發現，ESP 和 AH 最大的差別應該是 AH 會對於 Outer IP header 做驗證，所以其實 IPSec 唯有使用 ESP tunnel mode 才能和 NAT 共存。<br>而在 <a href="https://tools.ietf.org/html/rfc3948" target="_blank" rel="noopener">RFC 3948</a> 裡面也有寫道: <code>Because the protection of the outer IP addresses in IPsec AH is inherently incompatible with NAT, the IPsec AH was left out of the scope of this protocol specification.</code> 證實我們的推論應該是無誤的，難怪 AWS 的 NAT 教學裡面都是用 ESP 來做連線啊 QQ。<br>ESP 使用 port 50。</p><p><img src="/img/2018-03/ESP.png" alt="ESP.png"></p><h2 id="Transport-mode-amp-Tunnel-mode"><a href="#Transport-mode-amp-Tunnel-mode" class="headerlink" title="Transport mode &amp; Tunnel mode"></a>Transport mode &amp; Tunnel mode</h2><p>Transport mode: 通常是直接建立在兩台主機上，因為不需要再多加一個 IP header ，整體來說較省頻寬，在這個模式下，兩邊的主機都要安裝 IPSec 的 protocal，而且不能隱藏主機的 IP 位置。<br>Tunnel mode: 針對 Firewall 或是 Gateway proxy，一般來說我們會用這個模式，因為他們不是原本的發送收端。</p><h2 id="Security-Associations"><a href="#Security-Associations" class="headerlink" title="Security Associations"></a>Security Associations</h2><p>IPsec 中最重要的其實是 SA，因為它定義了如何協商，還有要使用哪些 Policy 和參數</p><ol><li>Authentication method</li><li>Encryption algorithm &amp; hashing algorithm</li><li>Life time of SA</li><li>Sequence number (避免 replay 攻擊)</li></ol><p>而基本上 SA 是單向的，所以通常要建立兩條 SA (from A to B and B to A)，然後這些 parameter 會經過 Internet Key Exchange (IKE) protocal 來決定，IKE 主要有分兩個 step</p><p>IKE phase1: 主要做 Authenticate，Authentication 方面常常使用的都是 pre-shared key，基本上就是用同一組密碼，接著透過 Diffie-Hellman 來建立一組 Key，而這組 Key 是要被 Phase2 拿來用的。<br>IKE phase2: 處理 IPsec security 協商，最後 IPSec SA 完成，接下來才會建立 IPSec 的連線。</p><p>** IKE 主要走 port 500</p><h2 id="結論"><a href="# 結論" class="headerlink" title="結論"></a>結論 </h2><p> 這只是一篇小小的筆記，而網路上面有更多詳細的資料，但有了這些基本概念後，對於為什麼 VPN 打不通，會有更多除錯的方法，像是那些 port 是不是沒開，或是 SA 整個設定錯誤，導致雙方協商失敗等等，會讓我們更有方向。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://chunchaichang.blogspot.tw/2011/12/ipsec-nat-t.html" target="_blank" rel="noopener">http://chunchaichang.blogspot.tw/2011/12/ipsec-nat-t.html</a></li><li><a href="https://www.jannet.hk/zh-Hant/post/internet-protocol-security-ipsec/" target="_blank" rel="noopener">https://www.jannet.hk/zh-Hant/post/internet-protocol-security-ipsec/</a></li><li><a href="https://en.wikipedia.org/wiki/IPsec#Security_association" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/IPsec#Security_association</a></li><li><a href="https://tools.ietf.org/html/rfc3948" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc3948</a></li><li><a href="http://www.deepsh.it/networking/IPSec.html" target="_blank" rel="noopener">http://www.deepsh.it/networking/IPSec.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;# 前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言 &lt;/h1&gt;&lt;p&gt; 這篇筆記是用來記錄 IPSec protocal 的一些細節，前陣子在架設 AWS VPN 的時候，遇到了一些小問題，主要還是防火牆擋
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://kkc.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS VPN with RouterBoard</title>
    <link href="http://kkc.github.io/2018/03/14/AWS-VPN-with-RouterBoard/"/>
    <id>http://kkc.github.io/2018/03/14/AWS-VPN-with-RouterBoard/</id>
    <published>2018-03-14T08:37:16.000Z</published>
    <updated>2018-09-09T16:12:56.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This post is used to note down how to setup Managed VPN connection between office to AWS by using Mikrotik RouterBoard. We basically follow instructions of <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_VPN.html" target="_blank" rel="noopener">this document</a> and it litterally describes everything we need to know. AWS supports Internet Protocol security (IPsec) VPN connections. Following figure shows the architecture of VPN connection.</p><p><img src="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/images/VPN_Basic_Diagram.png" alt="VPN_Basic_Diagram.png"></p><h1 id="Components-of-VPN"><a href="#Components-of-VPN" class="headerlink" title="Components of VPN"></a>Components of VPN</h1><h2 id="Virtual-Private-Gateway"><a href="#Virtual-Private-Gateway" class="headerlink" title="Virtual Private Gateway"></a>Virtual Private Gateway</h2><p>A virtual private gateway is the VPN concentrator on the Amazon side of the VPN connection. We can specify the Autonomous System Number (ASN) for the Amazon side of the gateway.</p><h2 id="Customer-Gateway"><a href="#Customer-Gateway" class="headerlink" title="Customer Gateway"></a>Customer Gateway</h2><p>A customer gateway should be a device or software VPN on our side for VPN connection.</p><p>we should define following items</p><ul><li>Internet-routable IP address: Our side public IP address</li><li>The type of routing: static or dynamic</li></ul><p>One thing we need to know is that VPN connection is initiated by our side.</p><h2 id="AWS-Managed-VPN"><a href="#AWS-Managed-VPN" class="headerlink" title="AWS Managed VPN"></a>AWS Managed VPN</h2><p>By using AWS managed VPN, we can have several benefits.</p><ul><li>Fully managed by AWS, and AWS also provides HA for us. we no longer need to worry about VPN disconnection issues while zone down.</li><li>IPSec site-to-site tunnel with AES-256, SHA-2.</li></ul><h1 id="Our-Settings"><a href="#Our-Settings" class="headerlink" title="Our Settings"></a>Our Settings</h1><p>In this article, we will try to use BGP routing connecting with AWS managed VPN.</p><p><img src="/img/2018-03/bgp-routing.png" alt="bgp_routing"></p><h2 id="In-AWS-side"><a href="#In-AWS-side" class="headerlink" title="In AWS side:"></a>In AWS side:</h2><ol><li>Open the Amazon VPC console at <a href="https://console.aws.amazon.com/vpc/" target="_blank" rel="noopener">https://console.aws.amazon.com/vpc/</a>.</li><li>Choose Virtual Private Gateways, Create Virtual Private Gateway and create a virtual private gateway.<ul><li>attach VPC that you wanna connect to</li></ul></li><li>Create a Customer Gateway</li><li>choose <strong>VPN Connections, Create VPN Connection.</strong><ul><li>specify Virtual Private Gateway and Customer Gateway</li><li>Routing Options → BGP</li></ul></li><li>Route Tables → <strong>Route Propagation</strong></li></ol><h2 id="In-Customer-Network"><a href="#In-Customer-Network" class="headerlink" title="In Customer Network:"></a>In Customer Network:</h2><ol><li>Download configuration file from AWS VPN connections:<ul><li>vendor: Mitrotik</li><li>Platform: RouterOS</li><li>Software: 6.36</li></ul></li><li>Download routerboard script generator from <a href="https://github.com/kkc/aws-vpn-mikrotik" target="_blank" rel="noopener">https://github.com/kkc/aws-vpn-mikrotik</a></li><li>Run script by using ./dynamic-router-config vpn-94e3fff5.txt</li><li>Performing script mikrotik-aws-config at routerboard</li></ol><p>Example of routerboard config<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tunnel1 &amp; tunnel2 CIDR</span></span><br><span class="line"><span class="built_in">/ip </span>addr</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">address</span>=169.254.47.58/30 <span class="attribute">interface</span>=ether1-WAN</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">address</span>=169.254.46.146/30 <span class="attribute">interface</span>=ether1-WAN</span><br><span class="line"></span><br><span class="line"><span class="comment"># ipsec proposal</span></span><br><span class="line"><span class="built_in">/ip ipsec </span>proposal</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">auth-algorithms</span>=sha1 <span class="attribute">comment</span>=<span class="string">"AWS PROPOSAL"</span> <span class="attribute">enc-algorithms</span>=aes-128-cbc <span class="attribute">lifetime</span>=1h <span class="attribute">name</span>=aws <span class="attribute">pfs-group</span>=modp1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># ipsec policy</span></span><br><span class="line"><span class="built_in">/ip ipsec </span>policy</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">src-address</span>=0.0.0.0/0  <span class="attribute">src-port</span>=any <span class="attribute">dst-address</span>=10.0.0.0/16 <span class="attribute">dst-port</span>=any  <span class="attribute">protocol</span>=all <span class="attribute">action</span>=encrypt <span class="attribute">level</span>=require   <span class="attribute">ipsec-protocols</span>=esp  <span class="attribute">tunnel</span>=<span class="literal">yes</span> <span class="attribute">sa-src-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">sa-dst-address</span>=<span class="variable">$TUNNEL1_IP</span>  <span class="attribute">proposal</span>=aws <span class="attribute">priority</span>=0</span><br><span class="line"></span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">src-address</span>=0.0.0.0/0  <span class="attribute">src-port</span>=any <span class="attribute">dst-address</span>=10.0.0.0/16 <span class="attribute">dst-port</span>=any  <span class="attribute">protocol</span>=all <span class="attribute">action</span>=encrypt <span class="attribute">level</span>=require    <span class="attribute">ipsec-protocols</span>=esp  <span class="attribute">tunnel</span>=<span class="literal">yes</span> <span class="attribute">sa-src-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">sa-dst-address</span>=<span class="variable">$TUNNEL2_IP</span> <span class="attribute">proposal</span>=aws <span class="attribute">priority</span>=0</span><br><span class="line"></span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">src-address</span>=0.0.0.0/0  <span class="attribute">src-port</span>=any <span class="attribute">dst-address</span>=169.254.47.57/32 <span class="attribute">dst-port</span>=any <span class="attribute">protocol</span>=all <span class="attribute">action</span>=encrypt <span class="attribute">level</span>=require <span class="attribute">ipsec-protocols</span>=esp  <span class="attribute">tunnel</span>=<span class="literal">yes</span> <span class="attribute">sa-src-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">sa-dst-address</span>=<span class="variable">$TUNNEL1_IP</span>  <span class="attribute">proposal</span>=aws <span class="attribute">priority</span>=0</span><br><span class="line"></span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">src-address</span>=0.0.0.0/0  <span class="attribute">src-port</span>=any <span class="attribute">dst-address</span>=169.254.46.145/32 <span class="attribute">dst-port</span>=any  <span class="attribute">protocol</span>=all <span class="attribute">action</span>=encrypt <span class="attribute">level</span>=require <span class="attribute">ipsec-protocols</span>=esp  <span class="attribute">tunnel</span>=<span class="literal">yes</span> <span class="attribute">sa-src-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">sa-dst-address</span>=<span class="variable">$TUNNEL2_IP</span>  <span class="attribute">proposal</span>=aws <span class="attribute">priority</span>=0</span><br><span class="line"></span><br><span class="line"><span class="built_in">/ip ipsec </span>peer</span><br><span class="line">     <span class="builtin-name">add</span> <span class="attribute">address</span>=<span class="variable">$TUNNEL1_IP</span>/32 <span class="attribute">local-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">passive</span>=<span class="literal">no</span> <span class="attribute">port</span>=500 <span class="attribute">auth-method</span>=pre-shared-key <span class="attribute">secret</span>=<span class="variable">$YOUR_SECRET</span> <span class="attribute">generate-policy</span>=<span class="literal">no</span> <span class="attribute">exchange-mode</span>=main <span class="attribute">send-initial-contact</span>=<span class="literal">yes</span> <span class="attribute">nat-traversal</span>=<span class="literal">no</span>      <span class="attribute">proposal-check</span>=obey <span class="attribute">hash-algorithm</span>=sha1 <span class="attribute">enc-algorithm</span>=aes-128 <span class="attribute">dh-group</span>=modp1024 <span class="attribute">lifetime</span>=8h <span class="attribute">lifebytes</span>=0 <span class="attribute">dpd-interval</span>=10s      <span class="attribute">dpd-maximum-failures</span>=3</span><br><span class="line"> </span><br><span class="line">     <span class="builtin-name">add</span> <span class="attribute">address</span>=<span class="variable">$TUNNEL2_IP</span>/32 <span class="attribute">local-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">passive</span>=<span class="literal">no</span> <span class="attribute">port</span>=500 <span class="attribute">auth-method</span>=pre-shared-key      <span class="attribute">secret</span>=<span class="variable">$YOUR_SECRET</span> <span class="attribute">generate-policy</span>=<span class="literal">no</span> <span class="attribute">exchange-mode</span>=main <span class="attribute">send-initial-contact</span>=<span class="literal">yes</span> <span class="attribute">nat-traversal</span>=<span class="literal">no</span>      <span class="attribute">proposal-check</span>=obey <span class="attribute">hash-algorithm</span>=sha1 <span class="attribute">enc-algorithm</span>=aes-128 <span class="attribute">dh-group</span>=modp1024 <span class="attribute">lifetime</span>=8h <span class="attribute">lifebytes</span>=0 <span class="attribute">dpd-interval</span>=10s      <span class="attribute">dpd-maximum-failures</span>=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># firewall rules</span></span><br><span class="line"><span class="built_in">/ip firewall </span>filter</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">chain</span>=input <span class="attribute">action</span>=accept <span class="attribute">protocol</span>=ipsec-esp <span class="attribute">src-address</span>=<span class="variable">$TUNNEL1_IP</span> <span class="attribute">dst-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">in-interface</span>=ether1-WAN   <span class="attribute">place-before</span>=1</span><br><span class="line"> </span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">chain</span>=input <span class="attribute">action</span>=accept <span class="attribute">protocol</span>=udp <span class="attribute">src-address</span>=<span class="variable">$TUNNEL1_IP</span> <span class="attribute">dst-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">in-interface</span>=ether1-WAN <span class="attribute">src-port</span>=500  <span class="attribute">dst-port</span>=500   <span class="attribute">place-before</span>=1</span><br><span class="line"> </span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">chain</span>=input <span class="attribute">action</span>=accept <span class="attribute">protocol</span>=ipsec-esp <span class="attribute">src-address</span>=<span class="variable">$TUNNEL2_IP</span> <span class="attribute">dst-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">in-interface</span>=ether1-WAN   <span class="attribute">place-before</span>=1</span><br><span class="line"> </span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">chain</span>=input <span class="attribute">action</span>=accept <span class="attribute">protocol</span>=udp <span class="attribute">src-address</span>=<span class="variable">$TUNNEL2_IP</span> <span class="attribute">dst-address</span>=<span class="variable">$YOUR_OFFICE_PUBLIC_IP</span> <span class="attribute">in-interface</span>=ether1-WAN <span class="attribute">src-port</span>=500 <span class="attribute">dst-port</span>=500   <span class="attribute">place-before</span>=1</span><br><span class="line"> </span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">chain</span>=input <span class="attribute">action</span>=accept <span class="attribute">protocol</span>=tcp <span class="attribute">src-address</span>=169.254.47.57 <span class="attribute">dst-address</span>=169.254.47.58 <span class="attribute">dst-port</span>=179   <span class="attribute">place-before</span>=1</span><br><span class="line"> </span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">chain</span>=input <span class="attribute">action</span>=accept <span class="attribute">protocol</span>=tcp <span class="attribute">src-address</span>=169.254.46.145 <span class="attribute">dst-address</span>=169.254.46.146 <span class="attribute">dst-port</span>=179  <span class="attribute">place-before</span>=1</span><br><span class="line"> </span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">chain</span>=forward <span class="attribute">action</span>=accept <span class="attribute">src-address</span>=10.0.0.0/16 <span class="attribute">in-interface</span>=ether1-WAN</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">chain</span>=forward <span class="attribute">action</span>=accept <span class="attribute">dst-address</span>=10.0.0.0/16 <span class="attribute">in-interface</span>=ether2-master</span><br><span class="line"> </span><br><span class="line"><span class="comment"># nat rule</span></span><br><span class="line"><span class="comment"># critically important to AWS connectivity that this rule be ahead of "masquerade".</span></span><br><span class="line"><span class="built_in">/ip firewall </span>nat</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">comment</span>=AWS-VPN <span class="attribute">chain</span>=srcnat <span class="attribute">action</span>=src-nat <span class="attribute">to-addresses</span>=192.168.0.0/24 <span class="attribute">dst-address</span>=10.0.0.0/16 <span class="attribute">place-before</span>=0</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">comment</span>=AWS-VPN <span class="attribute">chain</span>=dstnat <span class="attribute">action</span>=accept <span class="attribute">src-address</span>=10.0.0.0/16 <span class="attribute">in-interface</span>=ether1-WAN <span class="attribute">place-before</span>=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">/routing bgp </span>instance</span><br><span class="line">  <span class="builtin-name">set</span><span class="built_in"> default </span><span class="attribute">disabled</span>=<span class="literal">yes</span></span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">as</span>=65101 <span class="attribute">client-to-client-reflection</span>=<span class="literal">no</span> <span class="attribute">name</span>=vgw-1 <span class="attribute">redistribute-static</span>=<span class="literal">yes</span> <span class="attribute">router-id</span>=169.254.47.58</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">as</span>=65101 <span class="attribute">client-to-client-reflection</span>=<span class="literal">no</span> <span class="attribute">name</span>=vgw-2 <span class="attribute">redistribute-static</span>=<span class="literal">yes</span> <span class="attribute">router-id</span>=169.254.46.146</span><br><span class="line"> </span><br><span class="line"><span class="built_in">/routing bgp </span>network</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">network</span>=192.168.0.0/24</span><br><span class="line"> </span><br><span class="line"><span class="built_in">/routing bgp </span>peer</span><br><span class="line">  <span class="builtin-name">add</span> <span class="attribute">hold-time</span>=30s <span class="attribute">instance</span>=vgw-1 <span class="attribute">name</span>=a</span><br></pre></td></tr></table></figure></p><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>If the connection doesn’t work due to some reason, we can try following troubleshooting step.</p><p>Verify interesting traffic</p><ul><li>ESP =&gt; allow IP protocal 50 open</li><li>IPSEC Phase2 =&gt; Verify encryption parameter AES-128 and hashing parameter SHA-1</li><li>IPSEC PHase2 =&gt; Lifetime is configured to 3600s or 1hour</li><li>Ensure that perfect forward (PFS) is enabled</li><li>Verify port 500 is not blocked</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.youtube.com/watch?v=eNxPhHTN8gY" target="_blank" rel="noopener">AWS re:Invent 2017: Deep Dive: AWS Direct Connect and VPNs (NET403)</a></li><li><a href="https://helpx.adobe.com/enterprise/using/create-vpn-connection.html" target="_blank" rel="noopener">Create IPSec VPN connection between AWS VPC and customer network</a></li><li><a href="https://www.youtube.com/watch?v=7V2tf2zgerc" target="_blank" rel="noopener">How do I troubleshoot phase 1 IKE issues with an AWS VPN connection</a></li><li><a href="https://www.youtube.com/watch?v=OnkhrzFzQT8" target="_blank" rel="noopener">How do I troubleshoot phase 2 IKE issues with an AWS VPN connection</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;This post is used to note down
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://kkc.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>TCP Network Performance Tuning 筆記</title>
    <link href="http://kkc.github.io/2017/12/18/Network-Performance-Tuning/"/>
    <id>http://kkc.github.io/2017/12/18/Network-Performance-Tuning/</id>
    <published>2017-12-18T01:26:17.000Z</published>
    <updated>2018-09-09T15:07:43.988Z</updated>
    
    <content type="html"><![CDATA[<p>這篇速記主要紀錄看了 AWS reinvent 這個影片的心得，裡面講解怎麼 tuning TCP 相關的 networking issue，影片來源在此<br><div class="video-container"><iframe src="//www.youtube.com/embed/LjeXZItav34" frameborder="0" allowfullscreen></iframe></div></p><p>相當推薦這個影片，裡面不僅提到一些 TCP 上面的學術名詞，也很實際的告訴你在 linux 上面怎麼改變那些值，然後還可以看到在 application 的 benchmark 有很大的差距，這是我之前想像不到的，居然更改了一些設定可以有那麼巨大的差別。</p><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>講到 TCP ，講者一開始打賭大家第一個想到的，一定是 3 way handshake，一定是 SYN-ACK，但其實 TCP 很棒的地方在於，它提供了一個抽象層，然後我們不需要知道中間到底 packet 發生什麼情況，TCP 會幫忙處理類似重傳，還有要送多快不會掉包的問題，盡最大的可能讓 packet 到達目的地，並且保證封包到達的順序性。</p><ul><li>TCP does well on flow control</li><li>it makes sure it sends as many packets as it can without overwhelming the receiver.</li></ul><h1 id="TCP-optimization"><a href="#TCP-optimization" class="headerlink" title="TCP optimization"></a>TCP optimization</h1><p>主要有幾個重點</p><h2 id="Receive-Window"><a href="#Receive-Window" class="headerlink" title="Receive Window"></a>Receive Window</h2><p>接收端的流量控制</p><p><img src="https://hpbn.co/assets/diagrams/19e54ddeee77adfc1c724b912f7b2694.svg" alt="flow_control"></p><p>傳送數據的時候，如果對方收不下那麼多封包，就會產生 packet drop 的現象，為了避免這種現象發生，接收方要回報自己的 Receive Window (RWND) 有多大，傳送方知道了這個數值後，才不會多送封包過去造成浪費。而 Receive Window 基本上跟接收方開多少 Receive buffer 有關，在 linux 這邊可以用 <code>sysctl -a</code> 去查 RWND 的大小</p><p><code>sysctl -a | grep mem</code><br><code>net.ipv4.tcp_rmem = &lt;MIN&gt; &lt;DEFAULT&gt; &lt;MAX&gt;</code></p><p>有些人會遇到明明網卡很強，網路 bandwidth 也很大，尤其在內網的情況，為什麼網路速度還是上不來，有時候其實只是這個值在搞鬼。<br>而另外一點是，RWND 要設定到多少才是合理？設太大會吃掉太多 linux 的 Memory，設太小又會造成接收資料堵塞，實際上 RWND 的正常值是跟<a href="https://en.wikipedia.org/wiki/Bandwidth-delay_product" target="_blank" rel="noopener">BDP</a> 有相關，也就是跟 bandwidth 和 RTT (round trip time) 有相關，RTT 是指兩台主機間的延遲，你發出 request 後過了多久收到 response 基本上就是 RTT。</p><p>BDP 的公式，假如 bandwidth 是 100Mbps，而 RTT 是 100ms<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BDP = <span class="number">100</span>Mbps * <span class="number">100</span>ms = (<span class="number">100</span> / <span class="number">8</span>) * (<span class="number">100</span> / <span class="number">1000</span>) = <span class="number">1.25</span>MB</span><br></pre></td></tr></table></figure></p><p>在這個公式中，接收端 in-flight 就可以吃下 1.25MB 的資料，所以 RWND 不應該設定小於 1.25MB</p><h2 id="Congestion-control"><a href="#Congestion-control" class="headerlink" title="Congestion control"></a>Congestion control</h2><p>傳送端的流量控制</p><p>傳送端也可以做流量管制，因為 RWND 只有反應接收方的電腦狀態，而沒辦法確切代表整體網路，而且現在網路的的品質其實差距很大，像是 wifi，4G/5G 和有線網路就有很大的差別，所以傳送端這邊也有非常多的演算法，來推導發送多少的 packet 才會是最好的，減少半途消失的損失。</p><p>這邊演算法有根據不同的情況而產生的設計</p><ul><li>Packet LOSS</li><li>Latency</li><li>Bandwidth</li></ul><h3 id="TCP-slow-start"><a href="#TCP-slow-start" class="headerlink" title="TCP slow start"></a>TCP slow start</h3><p>TCP slow start 的概念就是一開始先送小一點的資料量，再慢慢增加到會掉包的程度，最後在減少發送量，以期找到最佳的傳輸大小，這邊就引入了一個值叫做 Congestion Window (CWND)，透過更改 CWND 的大小去找到最佳值。</p><p><img src="https://hpbn.co/assets/diagrams/e76659d1dbe30bbf31d9a5ef6238a236.svg" alt="congestion_control"></p><p>印象中 linux 舊版的 init CWND 是 <code>3MSS</code>，新版的 init CWND 則是 <code>10MSS</code>，一個 MSS 是 1448 bytes。</p><p>這邊有個例子讓大家感受一下 CWND 大小的影響，現在有個網頁是 20KB，如果是 3MSS(4.2KB)，在不考慮 CWND 會改變的情況下，需要發送將近 5 次，而改成 10MSS 則可以大幅降低傳輸次數。</p><h3 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h3><p>Loss 會造成 throughput 下降<br><img src="/img/2017-12/loss.png" alt="loss"></p><p>可以透過觀察 TCP retransmissions 看有沒有 loss 發生<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s <span class="string">| grep retransmit</span></span><br></pre></td></tr></table></figure></p><p>但是這個指令不太好用，因為無法看到是哪個 TCP 連線造成的，也沒有時間的資訊，只能靠一直 polling 去畫圖才會比較好用。</p><p>取而代之的是用 socket level 的 debug tool<br>使用 <code>ss -ite</code> 可以看到更多的資訊</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">send-Q: 多少資料在 <span class="built_in"> queue </span> 裡面需要被送出，如果這個值是 0，有可能是 application 裡面就卡住了，大於 0 才會是正常的</span><br><span class="line">cubic: congestion control algorithm</span><br><span class="line">rto: retransmission timeout</span><br><span class="line">cwnd: initial congestion control window</span><br><span class="line">retrans: 重送多少次</span><br></pre></td></tr></table></figure><p>另外這個影片有提到一個 tool 叫做 <code>tcpretrans</code><br>made by netflix brendangregg 可以拿來即時監控 retransmission</p><h3 id="Congestion-Control-Algorithm"><a href="#Congestion-Control-Algorithm" class="headerlink" title="Congestion Control Algorithm"></a>Congestion Control Algorithm</h3><p>Cubic: 2.6.19+ 目前我看我手上的 ubuntu 都是預設使用這個<br>Other algo: BBR, Vegas, illinois, Westwood, Highspeed, Scalable</p><h3 id="Retransmission-Timer"><a href="#Retransmission-Timer" class="headerlink" title="Retransmission Timer"></a>Retransmission Timer</h3><p>封包掉時，要經過多久才重送</p><ul><li>太低: congestion control 反應過度，而且重傳無法改善問題，只會造成網路更壅塞</li><li>太高: 增加 latency</li></ul><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>TC (traffic control) 可以製造一些 loss，還可以更改 qdisc 去做一些 network performance 測試<br>MTU: maximum transmission unit 在 VPC 內的 EC2 可以使用 Jumbo Frame 來溝通，使用 MTU 9001 會幫助蠻多的</p><h1 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h1><p>最後有個簡短的 experiment result</p><h2 id="case-1-Http-with-intermediate-network-loss"><a href="#case-1-Http-with-intermediate-network-loss" class="headerlink" title="case 1. Http with intermediate network loss"></a>case 1. Http with intermediate network loss</h2><p><img src="/img/2017-12/ex1.png" alt="ex1.png"><br><img src="/img/2017-12/ex1_res.png" alt="ex1_res.png"><br><img src="/img/2017-12/ex1_res2.png" alt="ex1_res2.png"><br>更改 TCP-BBR 不管在有無 loss 的情況下，拿來跟 cubic 對比，p50 都好上不好，不過 spike 其實會變多</p><h2 id="case-2-low-RTT-between-servers"><a href="#case-2-low-RTT-between-servers" class="headerlink" title="case 2. low RTT between servers"></a>case 2. low RTT between servers</h2><p><img src="/img/2017-12/ex2.png" alt="ex2.png"><br><img src="/img/2017-12/ex2_res.png" alt="ex2_res.png"><br><img src="/img/2017-12/ex2_res2.png" alt="ex2_res2.png"><br>更改 RTO 對 request 的 p99.99 有巨大的改善</p><h2 id="case-3-High-transaction-rate-HTTP-service"><a href="#case-3-High-transaction-rate-HTTP-service" class="headerlink" title="case 3. High transaction rate HTTP service"></a>case 3. High transaction rate HTTP service</h2><p><img src="/img/2017-12/ex3.png" alt="ex3.png"><br><img src="/img/2017-12/ex3_res.png" alt="ex3_res.png"><br>更改 init CWND，p50 latency 改善也很多，但是要注意需要的 Bandwidth 也會有所改變</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>圖片來源來自這本很棒的書<br><a href="https://hpbn.co/building-blocks-of-tcp/#congestion-avoidance-and-control" target="_blank" rel="noopener">https://hpbn.co/building-blocks-of-tcp/#congestion-avoidance-and-control</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇速記主要紀錄看了 AWS reinvent 這個影片的心得，裡面講解怎麼 tuning TCP 相關的 networking issue，影片來源在此&lt;br&gt;&lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//www.youtube.
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://kkc.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS fargate 的簡短筆記</title>
    <link href="http://kkc.github.io/2017/12/03/aws-fargate/"/>
    <id>http://kkc.github.io/2017/12/03/aws-fargate/</id>
    <published>2017-12-03T08:32:48.000Z</published>
    <updated>2018-09-09T12:44:49.475Z</updated>
    
    <content type="html"><![CDATA[<p>AWS reinvent 2017 推出了許多對 container 管理的新工具，基本上我原本以為有 K8s on AWS 就很厲害了，沒想到 AWS 也沒有想放棄 ECS，在這兩個 container orchestration 的方法上面又疊加了一層 managed system – fargate。</p><p>這篇主要是對這個 youtube 做的簡短筆記，但這裡他是用 ECS 作為例子，而針對 EKS 的 fargate 應該要等到 2018 才看得到了。</p><div class="video-container"><iframe src="//www.youtube.com/embed/0SceSgOTyrw" frameborder="0" allowfullscreen></iframe></div><h1 id="Fargate"><a href="#Fargate" class="headerlink" title="Fargate"></a>Fargate</h1><ul><li>No instance management</li><li>Task native API</li><li>Resource based pricing</li></ul><p>有談到 per seconds billing，根據選擇的 resource 類型來計價，會是新的 pricing model</p><h2 id="改良"><a href="# 改良" class="headerlink" title="改良"></a>改良 </h2><p> 以前在使用 ECS 的時候，其實有很多地方還是需要管理</p><ul><li>ECS cluster</li><li>EC2 instances (HA, resource provision, mantainence)<ul><li>docker daemon</li><li>ECS agent</li><li>OS version</li><li>…etc</li></ul></li></ul><p>而在使用 fargate 後，我們可以完全不去管理 EC2 這層，感覺概念跟 serverless 很像，我就把 task 丟上去，請你幫我好好管理後面調度的部分。</p><h2 id="Task-definition"><a href="#Task-definition" class="headerlink" title="Task definition"></a>Task definition</h2><p>fargate w/ ECS 也是沿用 ECS 的 task definition</p><p>Task definition</p><ul><li>Task size</li><li>Task execution role</li><li>network configuration for task placement<ul><li>VPC</li><li>Subnet</li><li>Security Group</li></ul></li></ul><h2 id="Network-w-fargate"><a href="#Network-w-fargate" class="headerlink" title="Network w/ fargate"></a>Network w/ fargate</h2><p><img src="/img/2017-12/fargate_network.png" alt="network"><br>針對每個 task 會有不同的 ENI 可以使用</p><ul><li>AWS VPC networking mode - each tasks get its own ENI</li><li>Full control of network interface vis SG and NACLs</li><li>Public IP support</li></ul><h2 id="security"><a href="#security" class="headerlink" title="security"></a>security</h2><p>權限劃分很重要</p><ul><li>cluster level isolation</li><li>permission<ul><li>cluster permission<ul><li>Who can run/see tasks in the cluster</li></ul></li><li>Application permission<ul><li>Which of mu AWS resource can this task access</li></ul></li><li>House keeping permission<ul><li>ECR</li><li>cloudwatch</li><li>…etc</li></ul></li></ul></li></ul><h1 id="結語"><a href="# 結語" class="headerlink" title="結語"></a>結語 </h1><p> 整個看起來，使用 fargate 好像會讓 container 管理變得更方便，但穩定性也是一大考驗，像是 AWS 的 ES，因為碰不到底層的 EC2，改個設定常常要跑半天，想起來如果用更 high level 的管理方式，常常改動需要等待更久的時間，也是犧牲了一點彈性，希望 fargate 不會有給我這樣的感覺。另外一方面，其實也有想過 AWS 的權限管理部分，真的需要有另外一層東西包起來，才能夠好好處理，這點我覺得 AWS 真的花蠻大的心力去解這問題，要不然直接用 k8s 跑，似乎在 compliance 上面都會有不少的難題要解。</p><p>Fargate 目前也只有少部分 region 可以使用，這邊許個願能夠在明年年中之前，讓大部分的 region 可用，這樣應該就夠了吧 (誤</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AWS reinvent 2017 推出了許多對 container 管理的新工具，基本上我原本以為有 K8s on AWS 就很厲害了，沒想到 AWS 也沒有想放棄 ECS，在這兩個 container orchestration 的方法上面又疊加了一層 managed 
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://kkc.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Retrieving AWS IP range</title>
    <link href="http://kkc.github.io/2017/11/17/aws-ip-range/"/>
    <id>http://kkc.github.io/2017/11/17/aws-ip-range/</id>
    <published>2017-11-16T19:39:05.000Z</published>
    <updated>2018-09-09T15:06:46.125Z</updated>
    
    <content type="html"><![CDATA[<p>It’s a simple note that how to get notifications while AWS IP range changed</p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p><a href="http://docs.aws.amazon.com/general/latest/gr/aws-ip-ranges.html" target="_blank" rel="noopener">http://docs.aws.amazon.com/general/latest/gr/aws-ip-ranges.html</a></p><p>AWS provides the ip range file, you can download from <a href="https://ip-ranges.amazonaws.com/ip-ranges.json" target="_blank" rel="noopener">ip-ranges.json</a></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jq  <span class="string">'.prefixes[] | select(.region=="us-east-1")'</span> &lt; ipranges.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"ip_prefix"</span>: <span class="string">"23.20.0.0/14"</span>,</span><br><span class="line">  <span class="string">"region"</span>: <span class="string">"us-east-1"</span>,</span><br><span class="line">  <span class="string">"service"</span>: <span class="string">"AMAZON"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"ip_prefix"</span>: <span class="string">"50.16.0.0/15"</span>,</span><br><span class="line">  <span class="string">"region"</span>: <span class="string">"us-east-1"</span>,</span><br><span class="line">  <span class="string">"service"</span>: <span class="string">"AMAZON"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"ip_prefix"</span>: <span class="string">"50.19.0.0/16"</span>,</span><br><span class="line">  <span class="string">"region"</span>: <span class="string">"us-east-1"</span>,</span><br><span class="line">  <span class="string">"service"</span>: <span class="string">"AMAZON"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>can use it to get specific IP range</p><h1 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h1><ul><li><p>Implementing Egress Control<br>  allow outbound traffic to the CIDR block in the Amazon list</p></li><li><p>Implementing Ingress Control<br>  while using different cloud or different platform, we can use it to define legal traffic</p></li></ul><h1 id="AWS-IP-Address-Ranges-Notifications"><a href="#AWS-IP-Address-Ranges-Notifications" class="headerlink" title="AWS IP Address Ranges Notifications"></a>AWS IP Address Ranges Notifications</h1><p>strongly recommened to set this up, really helpful<br><a href="http://docs.aws.amazon.com/general/latest/gr/aws-ip-ranges.html#subscribe-notifications" target="_blank" rel="noopener">http://docs.aws.amazon.com/general/latest/gr/aws-ip-ranges.html#subscribe-notifications</a></p><p>Keep Route53 Health check source IP’s up to date<br><a href="http://johntdyer.com/aws/2015/03/16/keep-route53-healthcheck-source-ips-up-to-date.html" target="_blank" rel="noopener">http://johntdyer.com/aws/2015/03/16/keep-route53-healthcheck-source-ips-up-to-date.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;It’s a simple note that how to get notifications while AWS IP range changed&lt;/p&gt;
&lt;h1 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://kkc.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Transaction 筆記</title>
    <link href="http://kkc.github.io/2017/10/08/transaction-note/"/>
    <id>http://kkc.github.io/2017/10/08/transaction-note/</id>
    <published>2017-10-08T04:48:47.000Z</published>
    <updated>2018-09-09T12:44:49.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h1><p> 大家都知道 RDBMS 其中有個主要的功能，就是能夠把 Transaction 這種任務，做得很完美，而 Transaction 這件事，在很多地方像是銀行轉帳或是進銷存的商業行為裡面，都是非常重要的，因為可以保證資料庫內的資料一致性。 而隨著 NOSQL 的蓬勃發展，看到很多 3rd party library 都想要在 application level 處理 Transaction 的議題，但往往好像使用者都沒搞懂，其實大部分的 lib 只有做到了 ACID 裡面的 Atomicity，而在多併發的環境下，不同的 transaction requests 其實是有機會把數據弄亂，這篇文章就是想要來複習一下 ACID 裡面 Isolation 這塊。</p><h1 id="ACID- 複習"><a href="#ACID- 複習" class="headerlink" title="ACID 複習"></a>ACID 複習 </h1><p>ACID &amp; RDBMS 的複習，推薦大家可以看看 <a href="https://www.youtube.com/watch?v=-exEZS_CEPU" target="_blank" rel="noopener">COSCUP 2017 VanillaDB - 由淺入深的教學型 RDBMS</a>，還有<a href="http://www.slmt.tw/slides/intro_vanilladb.pdf" target="_blank" rel="noopener"> 投影片 </a><br> 這邊也拿裡面銀行轉帳的例子，簡單講解一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Red"</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Blue"</span>;</span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">TRANSACTION</span>;</span><br></pre></td></tr></table></figure><ul><li><p>Atomicity: all or nothing<br>如果 Transaction 只完成了一部分操作，像是遇到斷電或是資料庫掛掉，該 Transaction 會整個被取消，所有數據會透過日誌復原。</p></li><li><p>Consistent:<br>在每一個操作的過程中，資料庫內的數據需要保持一致性，不會有 Transaction 執行到一半，去查詢資料時，資料庫內整體的餘額 (balance) 變成不一樣。</p></li><li><p>Isolation:<br>就算每一個 Transaction 中有 Atomicity 的特性，但是無法保證在同時執行多個 Transaction 時，能夠保證整個資料庫的一致性，這時候就需要 Isolation 這個特性來幫忙。</p></li><li><p>Duration:<br>資料庫內的資料不會因為斷電，系統崩潰而損失資料。</p></li></ul><h1 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h1><p>前面提到就算有 Atomicity 的特性，但是在多個 Transaction 情況下，還是有機會把數據搞亂，例如下面這個例子：</p><p>Transaction 1 將 $100 轉入給 A</p><ol><li>讀取 A 的值</li><li>這個值加上 $100 並寫回 A</li></ol><p>如果在這兩個操作中，有個 Transaction2 也修改了 A 的值加上 $100<br>原本的結果應該是 A 增加了 $200 ，但實際上 A 最後很可能只有加上了 $100</p><p>這也是為什麼我們要為 database 加上 Isolation，這樣才能讓 database 在修改數據時維持一致性，一般討論 Isolation 有數種隔離級別，其實基本上就是上鎖的概念，而鎖的顆粒度大小不一樣。</p><p>分為四個級別：</p><ol><li>Read Uncommitted</li><li>Read Committed</li><li>Repeatable-Read</li><li>Serializable</li></ol><p>為了瞭解這些級別的差距，我們必須要討論一下各個級別解決的問題是什麼。</p><h2 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h2><p>最一開始時，想要解決的就是兩個以上不同的 process 對同一筆數據做改變，而最基本的解決方法就是建立排他鎖 (eXclusive Locks or 寫鎖)</p><ol><li>啟動 Transaction A 時，該筆數據只能被此 Transaction 修改</li><li>其它 process 只能讀取</li></ol><p>這個級別我們就稱為 Read Umcommitted</p><h2 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h2><p>有了 Read Umcommitted 後，事情可沒就這樣結束了，後來大家馬上就發現到，如果 Transaction A 將某個值改變到一半，又把它 rollback 回去，這樣其他的 process 有可能讀取到錯誤的值，接著又把這個錯誤的值 commit 就糟糕了，這就是所謂的 <em>Dirty Read</em>，也就是讀取到還沒 commit 的值。</p><p><strong>Dirty read</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">update</span> field1</span><br><span class="line">B <span class="keyword">read</span> field1</span><br><span class="line">A <span class="keyword">rollback</span></span><br><span class="line">B <span class="keyword">commit</span></span><br></pre></td></tr></table></figure></p><p>這個時候其實只是需要調整鎖的程度，對於需要修改的數據，加上寫鎖後，需要到整個 Transaction 結束後才會釋放，而對於單純讀取 (SELECT) 的數據就沒有那麼嚴格，一但在 Transaction 內讀取完就釋放讀鎖。</p><h2 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable-Read"></a>Repeatable-Read</h2><p>這個級別主要是要解決 Unrepeatable read 的情況，當我們需要在一個 Transaction 裡面讀取同個 field 時，有可能會讀到不一樣的值， 情況有可能是這樣發生的，當 Transaction A 在讀取 Field1 時，同時間 Transaction B 改變了這個該值，當 Transaction A 再次讀取該值時，其數據就有可能被改變，這也是因為 read lock 會在 SELECT 完後馬上就被釋放，所以最簡單的方法就是把讀寫鎖釋放的時間延後到 Transaction 結束後，但壞處就是系統的效能會下降的很快，連讀取資料的部分也需要排隊讀取</p><p><strong>Unrepeatable read</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A read field1</span><br><span class="line">B <span class="keyword">update</span> field1</span><br><span class="line">B <span class="keyword">commit</span></span><br><span class="line">A <span class="keyword">read</span> field1</span><br></pre></td></tr></table></figure></p><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>最高的級別，一般資料庫不會使用到這個級別，而這個級別是要解決 phantom read 的問題，主要跟 Range query 比較有相關，舉例來說，當 Transaction A 使用 range query 查詢後得到 10 筆資料，而 Transaction B 在這個條件裡面新增了一筆資料並且 commit 後，Transaction A 在去 query 時，就會變成 11 筆資料。<br>但使用這個級別，最簡單的做法基本上就是鎖住整張表，以免不同的 Transaction 更動其資料，所以造成的效率低落也是可以想像的。</p><p><strong>phantom read</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A query =&gt; <span class="meta">get</span> <span class="number">10</span> <span class="meta">data</span></span><br><span class="line"><span class="keyword">B </span>insert <span class="number">1</span> <span class="meta">data</span></span><br><span class="line"><span class="keyword">B </span>commit</span><br><span class="line">A query =&gt; <span class="meta">get</span> <span class="number">11</span> <span class="meta">data</span></span><br></pre></td></tr></table></figure></p><h1 id="總結一下 -isolation-amp-lock- 的關係"><a href="# 總結一下 -isolation-amp-lock- 的關係" class="headerlink" title="總結一下 isolation &amp; lock 的關係"></a>總結一下 isolation &amp; lock 的關係</h1><p>from <a href="https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Read_phenomena" target="_blank" rel="noopener">wiki</a></p><table><thead><tr><th>Isolation level</th><th>Write Operation</th><th>Read Operation</th><th>Range Operation</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>until commit</td><td>not used</td><td>not used</td></tr><tr><td>Read Committed</td><td>until commit</td><td>during statement</td><td>not used</td></tr><tr><td>Repeatable Read</td><td>until commit</td><td>until commit</td><td>not used</td></tr><tr><td>Serializable</td><td>until commit</td><td>until commit</td><td>until commit</td></tr></tbody></table><p>順便借用一下 <a href="http://www.slmt.tw/blog/about/" target="_blank" rel="noopener">Yu-Shan Lin</a> 大大的投影片的圖</p><p><img src="/img/2017-10/database_isolation.png" alt="database_isolation.png"></p><h1 id="結語"><a href="# 結語" class="headerlink" title="結語"></a>結語 </h1><p> 複習了一下 RDBMS 的 ACID 概念，其實發現在提升 concurrency 的情況下，又要讓數據保持完整，其實是一件很困難的事情，而其實還有很多東西像是 MVCC、Row version、樂觀鎖、悲觀鎖還有死鎖等等東西，這篇都還來不及贅述，要實作真正的 Transaction 在 application 端其實是很複雜的，而 RDBMS 其實都很好的幫我們處理完這些問題，所以要處理數據且需要 Transaction 的話，還是推薦交給專業的工具，而不要自己傻傻的刻一套啊。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Isolation_(database_systems)</a></li><li><a href="https://www.zhihu.com/question/30272728" target="_blank" rel="noopener">https://www.zhihu.com/question/30272728</a></li><li><a href="https://technet.microsoft.com/en-us/library/ms187101(v=sql.105).aspx" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/library/ms187101(v=sql.105).aspx</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;# 前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言 &lt;/h1&gt;&lt;p&gt; 大家都知道 RDBMS 其中有個主要的功能，就是能夠把 Transaction 這種任務，做得很完美，而 Transaction 這件
      
    
    </summary>
    
    
      <category term="RDBMS" scheme="http://kkc.github.io/tags/RDBMS/"/>
    
  </entry>
  
  <entry>
    <title>淺談 Asynchronous Programming</title>
    <link href="http://kkc.github.io/2017/09/01/asynchronous-programming/"/>
    <id>http://kkc.github.io/2017/09/01/asynchronous-programming/</id>
    <published>2017-09-01T14:08:31.000Z</published>
    <updated>2018-09-09T12:44:49.473Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//www.slideshare.net/slideshow/embed_code/key/2OtC3FTsUFvtNN" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <p> 利用這篇文章稍微紀錄一下，最近在公司分享的淺談 Asynchronous programming 的心得，其實在現在各個網路公司盛行的時代，不懂點 Asynchronous model 應該是不太可能的，而且就算不懂實際上大家也是天天在用，類似寫 Browser 端的 javascript，或是不論 nodejs 或是 python (像是 gevent)，都常常看到大家再談 Asynchronous model 對 performance 帶來的好處，正好同事們很多人正在學 javascript，而有些人似乎不知道最初是在解決什麼問題，所以才會有這個投影片的誕生，不過因為太多方法可以處理 Asynchronous model，我並沒有講得太深入，很多地方只有點到為止，希望之後有機會能夠再補充一些。</p><p> 所以到底 Asncyhronous or concurrency 解決了什麼問題呢？一言以敝之，追根究底就是消除等待。<br>concurrency 主要拿來跟 parallellism 比較，concurrency 談的其實就是能夠在同一時間完成很多事情，我喜歡拿做菜為例子，就算只有一個廚師，他還是可以在同時間完成切菜，準備醬料，煮菜等等工作，他會在中間切換來切換去，而不會等到一盤菜好了，再去準備接下來的事情，而 Parallellism 比較像是同時有很多 worker 做差不多事情。</p><p> 我們一般寫的程式，其實大部分都在處理這種問題，像是 GUI 程式，使用者按了一個 button 後，你不可能完全卡在那邊等待其他的程式跑完，又像是你的 API server 經由網路呼叫一個 3rd party 的外部程式，如果你在那邊傻傻的等，是不是浪費了很多 CPU resource。這時候我猜大家都很聰明想到可以直接用 thread 去操作，避免掉 main process 被卡住的情況，而其實 thread 也算是一種 aysnchronous programming 的 model，而且現今的程式語言也有更好語法去使用它們，像是用 Future or Promise。</p><p> 在瞭解完要解決什麼問題後，需要知道的是不同解法之間的差異，因為公司同仁大部分都是寫 javascript 或是 python，所以在 asynchronous flow 上面比較多著墨 callback, eventloop, coroutine 還有最後衍生出來的 async/await，而 javascript 天生就使用一個 thread 去達成 concurrency，這點感覺有點奇妙，所以需要先補充一些 linux IO 的知識，像是 blocking IO/non-blocking IO 的差別，最後導出 IO multiplexing 才能講得下去 event loop 怎麼實作的，nginx 之類的 service 就是利用了 IO multiplexing 才有效的解決 <a href="https://en.wikipedia.org/wiki/C10k_problem" target="_blank" rel="noopener">C10K</a> 的問題，使用一個 thread 處理 network IO 請求，其實就減少了增減 thread 的開銷，memory 的使用量也大減，但取而代之的就是，程式會有點難寫難讀，所以就有了 libev, libevent, libuv 這類 library 幫忙處理 asynchronous IO 這部分，使用這類的 lib，上層 program 很簡單就可以使用 callback function 與之互動，等到 socket 的 file descriptor 被 trigger 時再去呼叫 callback 繼續處理下去。</p><p> 在有了 callback 後，世界並不是就太平了，很快就有人發現可以寫出 callback hell 這種程式，asynchronous progrmamming (主要談 callback) 到這邊就變成語法的改進了，希望能夠把程式寫得更漂亮更易讀一點，所以就有了 promise 或是 coroutine 的方法與其結合，在 coroutine 中會把控制權從 function 中切換回 main task 中，某種程度跟 eventloop 就很相似，所以可以利用 coroutine 的特性加上 non-blocking I/O 成為更好的框架，而程式也會變得像是 synchronous 的樣子，不過要注意一但有程式是 blocking IO 或是 cpu intensive 的任務，就會把這個 thread 卡住，最後提到的 async/await 只不過是語法的變形，其實跟 coroutine 的概念是很相似的，可以讓整個程式更好寫易讀，然後背後又能高效率的處理 IO bound 問題。</p><p> 最後來總結一下，其實這些方法都是為了解決一些任務太慢而產生的，在我們當使用者的時候 (caller)，實際上也許不知道背後這些 async module 是如何運作的，除非是自己要一手從下到上包辦，但還是有些點需要注意，如果這類程式只是處理 networking IO 的話，應該是不會有太大的問題，但如果中間有個 cpu intensive 的任務最好還是要能 fork 出 process/thread 去處理，或是利用 queue 丟給其他的 worker 去處理，所以一旦我們清楚這些架構後，才能知道採取哪種方式處理問題是比較好的。</p><p>Reference</p><ol><li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">What the heck is the event loop anyway</a> 非常棒的 javascript eventloop 講解 </li><li><a href="https://x.st/javascript-coroutines/" target="_blank" rel="noopener">javascript-coroutine</a></li><li><a href="https://codewala.net/2015/07/29/concurrency-vs-multi-threading-vs-asynchronous-programming-explained/" target="_blank" rel="noopener">concurrency-vs-multi-threading-vs-asynchronous-programming-explained</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/2OtC3FTsUFvtNN&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginhe
      
    
    </summary>
    
    
      <category term="programmming" scheme="http://kkc.github.io/tags/programmming/"/>
    
  </entry>
  
  <entry>
    <title>Coscup Golang 社群議程主持人之簡短心得！</title>
    <link href="http://kkc.github.io/2017/08/06/coscup-2017/"/>
    <id>http://kkc.github.io/2017/08/06/coscup-2017/</id>
    <published>2017-08-06T15:58:19.000Z</published>
    <updated>2018-09-09T12:44:49.473Z</updated>
    
    <content type="html"><![CDATA[<p>第一次在 Coscup 擔任議程主持人，說不緊張是假的，其實一開始還結巴哩，不過後來想想，講者應該比我還緊張，而我的責任其實是要好好照顧講者啊 (汗)。原本是要靠 <a href="https://twitter.com/Evan_Lin?lang=zh-tw" target="_blank" rel="noopener">@Evan</a> 大大撐場，很不幸的他剛好有事無法出席，而他找的代打者也剛好在議程這天有事，只好讓備案中的備案 — 我上場啦！，有種在 1A 打球突然被叫上大聯盟的感覺，不過還好 Golang 社群的小夥伴們都很幫忙，真的感受到社群的人好溫暖啊 Q_Q</p><p>設備部分的話，這次的投影機，在投放黑底白字或是字太小的時候都很悲劇，只能在瘋狂調整解析度的情況下，想辦法找個平衡點，希望下次主辦單位能夠先在各個教室幫測一下啊。然後場地其實我覺得還不錯，在教室上課好像回到大學時代喔，讓我很意外的是，我們 Golang 的社群議程居然大爆滿，整個擠到我們自已的門神都擠不進來 (笑)，害我很擔心大家會不會擠得很累，再加上我們經驗不足，其實不太會擋人 (台灣人都很 nice 的…XD)，好像造成一些些小混亂。</p><p>我覺得 Golang 最近好像真的紅起來了，其實一般來說這種程式語言的主題，都會擔心有點太小眾，但是感覺大家也是觀望的多，真心希望越來越多人能分享他們使用 Golang 的心得，多多的在討論區裡面討論，這樣可以讓大家少踩點雷，多學些不錯的 tool ，一起向上提升，逆轟高灰！</p><p>再來談到今天有點小出槌的地方，因為每個議程都只有 30 分鐘，其實我真的很怕講者講不完，所以第一個講者我就在五分鐘前，想說來暖個場，做個轉場，結果梗太少了，好像只花了一分鐘就交給講者，又因為該場地的時鐘不準，所以整整提前了五分鐘就開始，真是對不起還來不及進來的人。</p><p>主題的話，我覺得我們這次的內容包含蠻多面向的，我個人也學到不少，建議大家真的可以把直播和投影片拿來看看，先是學聰大大，講到使用 Marshal 時踩到什麼雷，藉由踩雷的過程中，學習 Golang 的 type system，從這場 talk 中，我也學到原來 type declarations 不是只是個 alias，詳細可以看 go 的 <a href="https://golang.org/ref/spec#Type_declarations" target="_blank" rel="noopener"> 文件</a>，而憶賢的 Golearn 也頗有趣，也真的有 contribute code 到這個專案，還有拿來實作學校作業，真的好棒棒啊！老鮑的 GRPC 大亂鬥這場一開始的 Demo 應該頗驚人，不愧是火力展示，感覺大家都醒過來了，講到 grpc 的特性和跟 restful protocal 的比較都很清楚，不愧是專業推坑的。接著是 browny 介紹 Dependency injection in golang，我覺得這堂課真的大推，因為講解得非常清楚，連我都想要偷偷拿來當內訓的教材，其實我也是近些年才真正搞懂相關名詞，雖然常常在用，但是有系統的整理相關知識還是蠻困難的，深入淺出的講解 DI 解決了什麼問題，再帶到 golang 的 DI framework，讓人接受為什麼要用這類的工具。最後是 appleboy 大大推坑 Gitea &amp; Drone ，其實我也是今天才第一次聽到 Gitea ，但是感覺到這個專案，其實還蠻認真的，而且世界各地有許多人投入這個專案，應該是可以期待跟 Gitlab 一較高下，改天可以來玩玩看！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次在 Coscup 擔任議程主持人，說不緊張是假的，其實一開始還結巴哩，不過後來想想，講者應該比我還緊張，而我的責任其實是要好好照顧講者啊 (汗)。原本是要靠 &lt;a href=&quot;https://twitter.com/Evan_Lin?lang=zh-tw&quot; targe
      
    
    </summary>
    
    
      <category term="golang" scheme="http://kkc.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>AWS route53 multivalue 筆記</title>
    <link href="http://kkc.github.io/2017/07/23/aws-route-53-multivalue/"/>
    <id>http://kkc.github.io/2017/07/23/aws-route-53-multivalue/</id>
    <published>2017-07-23T06:02:36.000Z</published>
    <updated>2018-09-09T12:44:49.473Z</updated>
    
    <content type="html"><![CDATA[<p>AWS 發表的新的 route53 routing policy: <a href="https://aws.amazon.com/about-aws/whats-new/2017/06/amazon-route-53-announces-support-for-multivalue-answers-in-response-to-dns-queries/" target="_blank" rel="noopener">multivalue</a>，Raddit 上面的某篇 <a href="https://www.reddit.com/r/aws/comments/6iptol/amazon_route_53_announces_support_for_multivalue/" target="_blank" rel="noopener"> 文章</a>，有比較了一下跟 simple &amp; weighted 的差別，但主要看這張圖就夠了 <a href="http://imgur.com/4gvktlm" target="_blank" rel="noopener">http://imgur.com/4gvktlm</a>。</p><ol><li>simple 是把 multiple values (IP) 寫成一筆 record，但是 multivalue 是寫成多筆，然後用 nslookup 去查看起來回應的結果是差不多的。</li><li>但其實還是有一點不同，<a href="http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html" target="_blank" rel="noopener">文件</a> 上面寫到 multivalue 最多只會 randomly 回 8 筆 healthy records。</li><li>multivalue 的好處是，每筆記錄可以跟 health check associate 在一起，當 endpoint failure 時會自動把這個 IP 拿掉。</li><li>weighted 的話，雖然也是多筆 records，但是用 nslookup 去查，基本上只會回一筆資料給你。</li><li>multivalue 如果全部 endpoint 都不 healthy，他最多也會回 8 筆 unhealthy records 。</li></ol><p>有了 multivalue 後其實原本只能用 weighted 做的事情就可以移過來了，像是用 ASG 開一堆機器，但是想用 DNS RR 來做 load distribution 就可以改用 multivalue 來實作，debug 時也可以看到全部的 dn list，對我來說更有彈性一點。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AWS 發表的新的 route53 routing policy: &lt;a href=&quot;https://aws.amazon.com/about-aws/whats-new/2017/06/amazon-route-53-announces-support-for-multi
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://kkc.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>MySQL partition 筆記</title>
    <link href="http://kkc.github.io/2017/07/07/mysql-partitioning/"/>
    <id>http://kkc.github.io/2017/07/07/mysql-partitioning/</id>
    <published>2017-07-07T15:35:05.000Z</published>
    <updated>2018-09-09T12:44:49.473Z</updated>
    
    <content type="html"><![CDATA[<p>最近要處理一件資料量不太大但是又超過 5kw 行的問題，問題是這樣的，需要一張 table 儲存上傳到 S3 影片的 metadata，像是 <code>id</code>, <code>timestamp</code>, <code>s3_url</code> 等等資料，然後過三個月就把之前的資料連同 metadata 砍掉，而想到簡單一點就用 mysql 的分區表來做就夠了，有人會問用 mongodb 分月切就好，但是其實在處理跨月的 range query 就需要自己在 application 端組合，相較之下 mysql 是在同一個 logic view 下面，對於程式邏輯可以變得比較簡單，更者可以直接用 ORM 來操作。</p><h1 id="分區表"><a href="# 分區表" class="headerlink" title="分區表"></a>分區表 </h1><p> 基本上我是用 AWS Aurora ，但主要還是參考了 <a href="https://dev.mysql.com/doc/refman/5.6/en/partitioning.html" target="_blank" rel="noopener">mysql 文件 </a>，因為 Aurora 是用 mysql 5.6 模改的。<br> 如同前言所講的，我需要處理一定量級的資料，但在資料量大到一定程度時，除非使用 covering index，要不然就會產生很多 disk 的 IO 去找資料，對於 performance 的下降是可以預期的，MySQL 的 Partitioning 會根據條件切分不同資料到不同的文件下，好處是在搜索時，index tree 變小了，搜索的資料量也變小了，插入時因為 index tree 沒那麼肥，也可以得到一定程度的改進，另外最大的好處就是移除分區表不會讓資料表造成碎片，很適合需要定期砍掉資料的場景。</p><h2 id="建立分區表"><a href="# 建立分區表" class="headerlink" title="建立分區表"></a>建立分區表 </h2><p> 可以使用下列 command 建立 table 與分區表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales &#123;</span><br><span class="line">    ...</span><br><span class="line">    created_at DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">&#125; <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(created_at)) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p2015 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2015</span>)</span><br><span class="line">    <span class="keyword">PARTITION</span> p2016 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2016</span>)</span><br><span class="line">    <span class="keyword">PARTITION</span> p2017 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2017</span>)</span><br><span class="line">    <span class="keyword">PARTITION</span> p9999 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>這樣就可以對於 year 來切分 partition，然後我個人踩過幾個雷，基本上只能用 <code>YEAR</code> 和 <code>TO_DAYS</code> 來切，要產生根據月份切資料就要自己帶入 <code>TO_DAYS(&#39;2017-07-01&#39;)</code> 這種語法，然後用 <code>MONTH</code> 語法產生的 partition 基本上是完全沒用的，因為查詢時他還是會查全部的 partition ，也不能用 Prune 其中的 partition，<a href="https://dev.mysql.com/doc/refman/5.6/en/partitioning-pruning.html" target="_blank" rel="noopener">官方文件 </a> 也有寫到 Prune 的議題 <code>Pruning can also be applied for tables partitioned on a DATE or DATETIME column when the partitioning expression uses the YEAR() or TO_DAYS() function.</code></p><h2 id="分區表的搜索"><a href="# 分區表的搜索" class="headerlink" title="分區表的搜索"></a>分區表的搜索 </h2><p> 要使用 <code>WHERE</code> 去定位使用哪個分區表，用以上的例子就是使用 <code>SELECT * FROM sales WHERE created_at &gt;= &#39;2017-06-01&#39; AND created_at &lt;= &#39;2017-07-01&#39;;</code></p><p>要看看使用了哪些分區，可以簡單用 <code>Explain partitions SELECT * FROM sales WHERE created_at &gt;= &#39;2017-06-01&#39; AND created_at &lt;= &#39;2017-07-01&#39;;</code></p><h2 id="移除分區表"><a href="# 移除分區表" class="headerlink" title="移除分區表"></a>移除分區表 </h2><p> 在維護 time-series 的 case 時，使用 <code>DROP PARTITION</code> 會比直接 <code>DELETE</code> 快上非常多！</p><h2 id="插入分區表"><a href="# 插入分區表" class="headerlink" title="插入分區表"></a>插入分區表 </h2><p> 如果 partition key 插入了 <code>NULL</code> 的值會導致過濾失效，然後全部資料都會掉入第一個分區表，所以要避免這個情況。<br>在 MySQL 5.5 後可以使用 <code>PARTITION BY RANGE COLUMNS(created_date)</code> 解決這個問題。</p><h2 id="Rotate-Partition"><a href="#Rotate-Partition" class="headerlink" title="Rotate Partition"></a>Rotate Partition</h2><p>在經過一段時間後，我們需要更動分區表，類似新增需要的分區表，還有刪除不必要的分區表，這時候可以使用 stored procedure + mysql event scheduler 來做，這裡有一個 stackoverflow 的 <a href="https://dba.stackexchange.com/questions/90863/whats-the-best-way-to-structure-logging-application-data-in-mysql" target="_blank" rel="noopener"> 範例</a>，照著改還算簡單，只是 mysql 的 stored procedure 真的有點難 debug。</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>有一篇文章叫做 <a href="http://mysql.rjweb.org/doc.php/partitionmaint" target="_blank" rel="noopener">PARTITION Maintenance in MySQL</a>，個人覺得還不錯，看了以後可以免去踩一些雷。</p><ol><li>除非資料量級到 &gt; 1M rows ，在考慮使用 mysql partition</li><li>不要開太多 partition (這個應該在 5.6 5.7 就不是太大的問題了)</li><li>只有 PARTITION BY RANGE 有用 (雖然 partition 還有其他 key, hash, list 的方法，但是真的很不實用 hmmm)</li><li>SUBPARTITION 不好用 (同感，有點難維護)</li><li>Partition key 不應該是 index key 的第一個</li><li>Partition key 需要是 Primary key 或是 Unique Key</li><li>如果 Partition key 是 dt ，通常 index 長得像 PRIMARY KEY (…, dt), UNIQUE KEY (…, dt)，會將他放在最後。</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://www.jianshu.com/p/01b9f028d9c7" target="_blank" rel="noopener">我必须得告诉大家的 MySQL 优化原理 2</a></li><li><a href="http://mysql.rjweb.org/doc.php/partitionmaint" target="_blank" rel="noopener">PARTITION Maintenance in MySQL</a></li><li><a href="http://www.vertabelo.com/blog/technical-articles/everything-you-need-to-know-about-mysql-partitions" target="_blank" rel="noopener">everything-you-need-to-know-about-mysql-partitions</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近要處理一件資料量不太大但是又超過 5kw 行的問題，問題是這樣的，需要一張 table 儲存上傳到 S3 影片的 metadata，像是 &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;s3_url&lt;/code&gt; 等等資料，
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://kkc.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>acs-engine-note</title>
    <link href="http://kkc.github.io/2017/06/16/acs-engine-note/"/>
    <id>http://kkc.github.io/2017/06/16/acs-engine-note/</id>
    <published>2017-06-16T14:14:36.000Z</published>
    <updated>2018-09-09T12:44:49.473Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Azure VMSS 的簡略使用筆記</title>
    <link href="http://kkc.github.io/2017/04/24/azure-note/"/>
    <id>http://kkc.github.io/2017/04/24/azure-note/</id>
    <published>2017-04-24T14:25:18.000Z</published>
    <updated>2018-09-09T12:44:49.472Z</updated>
    
    <content type="html"><![CDATA[<p>在踏入 Azure 領域前，因為原本比較熟悉 AWS，所以從 AWS 的 Service 尋找對應的 Azure Service 算是比較好入門的管道，基本上這個連結 <a href="https://docs.microsoft.com/zh-tw/azure/architecture/aws-professional/services" target="_blank" rel="noopener">Azure to AWS mapping</a> 算是整理的很不錯，不過也可以看得出來 Azure 也是設定大家都懂 AWS，想要從這邊搶客戶過來。</p><p>而會想試用 Azure，主要是 Azure 有新的 M60 的 GPU instance 可以玩，相比起 AWS 的 K80 好像強大不少，所以家裡老大叫我去測試一下。 接下來的幾篇文章主要會紀錄怎麼使用 Azure cli 到最後部署 GPU instance。</p><hr><h1 id="Azure-CLI"><a href="#Azure-CLI" class="headerlink" title="Azure CLI"></a>Azure CLI</h1><p>在被 Azure Portal 荼毒一陣子後，決心轉向使用 Azure 的 CLI，在這邊也要向大家推薦，Azure 的 CLI 真的比 Portal 好用一萬倍，很多東西都是 CLI 有但是 Portal 還在生的階段。</p><h2 id="Azure-CLI-Docker"><a href="#Azure-CLI-Docker" class="headerlink" title="Azure CLI Docker"></a>Azure CLI Docker</h2><p>如果覺得安裝很麻煩，這邊也有 Docker image 可以直接抓下來用</p><ul><li><a href="https://github.com/Azure/azure-cli-docker" target="_blank" rel="noopener">https://github.com/Azure/azure-cli-docker</a></li><li><a href="https://hub.docker.com/r/azuresdk/azure-cli-python/" target="_blank" rel="noopener">https://hub.docker.com/r/azuresdk/azure-cli-python/</a> -&gt; Microsoft Azure CLI 2.0 - Preview</li></ul><p>使用 <code>az login</code> 後就會產生相關的 config file，如果使用 docker container 想要保存其 config 的話，記得 mount 一個外部的 volume 進去。</p><h1 id="Azure-resource-group- 簡介"><a href="#Azure-resource-group- 簡介" class="headerlink" title="Azure resource group 簡介"></a>Azure resource group 簡介 </h1><p> 基本上現在使用 Azure，都會推薦你使用 Resource Group 來管理你的 Infrastructure ，這邊感覺跟 AWS 的 tag 有點像，就是可以把相關的組件分到同一個 Group 下面，如果想要看詳細的介紹可以左轉 <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-overview" target="_blank" rel="noopener"> 這邊 </a> 找</p><p>而我主要就是記錄一下怎麼用 Azure CLI 開個 VM &amp; resource group 。</p><h2 id="建立 -ARM-amp-VM"><a href="# 建立 -ARM-amp-VM" class="headerlink" title="建立 ARM &amp; VM"></a>建立 ARM &amp; VM</h2><p><img src="https://image.slidesharecdn.com/2016-02-25-vmss-ug-deep-dive-160226160609/95/uk-azure-users-group-7-638.jpg?cb=1456502858" alt="Azure Resource Group"><br>Azure resource group 的階層結構</p><ul><li>Azure Resource Group (把相關的組件加個這個 Group 下面管理）<ul><li>VNET<ul><li>Subnet<ul><li>NIC</li></ul></li></ul></li></ul></li></ul><p>而 VM 需要有 NIC 去得到 private ip/public ip</p><ol><li><p>建立 Resource Group</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azure<span class="built_in"> group </span>create myTestGroup -l southcentralus</span><br></pre></td></tr></table></figure></li><li><p>建立 Storage Account</p><p>這裡跟 AWS 有很大的差別，AWS 的 EBS 是獨立的架構，而 Azure 的 Storage 在使用前都需要建立 Storage Account，而底下又有四種類別 Blob, File, Tables, Queue，Azure VM 的 OSdisk &amp; DataDisk 都是存在 Blob 裡面，然後建立 Custom Image 也會被建立在同個 Storage Account 裡面。</p> <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">azure storage account create -g GROUPNAME \</span><br><span class="line">    -l <span class="keyword">LOCATION</span> <span class="title">--sku-name</span> LRS --kind storage STORAGENAME</span><br></pre></td></tr></table></figure></li><li><p>Create virtual net</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azure<span class="built_in"> network </span>vnet create myTestGroup TestVnet -l southcentralus</span><br></pre></td></tr></table></figure></li><li><p>Create subnet</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azure<span class="built_in"> network </span>vnet subnet create -a 10.0.0.0/16 myTestGroup TestVnet TestVnetSubnet</span><br></pre></td></tr></table></figure></li><li><p>Create public IP</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azure<span class="built_in"> network </span>public-ip create myTestGroup myTestPulibIP -l southcentralus</span><br></pre></td></tr></table></figure></li><li><p>Create Network interface (NIC)</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azure<span class="built_in"> network </span>nic create myTestGroup myTestNic -k TestVnetSubnet -m TestVnet -p myTestPulibIP -l southcentralus</span><br></pre></td></tr></table></figure></li><li><p>Create VM</p> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azure vm create -n myTest -l southcentralus -g myTestGroup -f myTestNic -z Standard_NV6 -y Linux --storage-account-name kakashistorage --<span class="keyword">generate</span>-ssh-keys -Q Canonical:UbuntuServer:<span class="number">16</span><span class="variable">.04</span><span class="variable">.0</span>-LTS:latest</span><br></pre></td></tr></table></figure></li></ol><h2 id="建立 -Custom-Image"><a href="# 建立 -Custom-Image" class="headerlink" title="建立 Custom Image"></a>建立 Custom Image</h2><p>在會開 VM 後，想要學習怎麼建立自己的 Custom Image，有點像是在 AWS 裡面去打 VM 的 AMI，這也是建立 immutable image 的一環。<br>參考資料為 <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/linux/capture-image" target="_blank" rel="noopener"> 這篇</a></p><ol><li><p>Deprovision your source VM</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh ops@myvm.westus.cloudapp.azure.com</span><br><span class="line">sudo waagent -deprovision+user -force</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></li><li><p>Deallocate the VM with az vm deallocate</p> <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm deallocate --resource-<span class="keyword">group</span> <span class="title">myResourceGroup</span> --name myVM</span><br></pre></td></tr></table></figure></li><li><p>Generalize the VM with az vm generalize</p> <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm generalize --resource-<span class="keyword">group</span> <span class="title">myResourceGroup</span> --name myVM</span><br></pre></td></tr></table></figure></li><li><p>Create an image from the VM resource with az image create:</p> <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">az</span> <span class="comment">image</span> <span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">resource</span><span class="literal">-</span><span class="comment">group</span> <span class="comment">myResourceGroup</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">name</span> <span class="comment">myImage</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">source</span> <span class="comment">myVM</span></span><br></pre></td></tr></table></figure></li></ol><p>下完建立 image 的指令後，其實會在相對應的 Azure blob Storage 下面開一個專門的資料夾去存這個 snapshot，然後檔名是 vhd<br><code>e.g: https://blahblahblah.blob.core.windows.net/images/Microsoft.Compute/Images/vhds/MyImage-osDisk.ef68b9e6-8081-4082-972c-2375b39953f8.vhd</code></p><p>感想: 這裡其實覺得比 AWS 難用多了，還需要做那麼多步驟。</p><p>(Optional) Create a VM from your image resource with az vm create</p><pre><code><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm create <span class="params">--resource-group</span> myResourceGroup <span class="params">--name</span> myVMDeployed <span class="params">--image</span> https:<span class="string">//blahblahblah.blob.core.windows.net/images/Microsoft.Compute/Images/vhds/MyImage-osDisk.ef68b9e6-8081-4082-972c-2375b39953f8.vhd</span> <span class="params">--admin-username</span> azureuser <span class="params">--ssh-key-value</span> ~<span class="string">/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure></code></pre><h2 id="使用 -Template- 部署 -VMSS"><a href="# 使用 -Template- 部署 -VMSS" class="headerlink" title="使用 Template 部署 VMSS"></a>使用 Template 部署 VMSS</h2><p>所謂的 VMSS 其實就是 Azure 版本的 Auto scaling group，基本上 MS 推薦大家在 Azure 上面用 Template 去作部署 (有點像 AWS 的 cloudformation) ，而很棒的地方是，他們在 Github 上面擺了一個 <a href="https://github.com/Azure/azure-quickstart-templates" target="_blank" rel="noopener">azure-quickstart-template</a> 非常實用，可以拿來一鍵部署，或是修改成你想要的架構。</p><p>而我則是使用以下這位大大的 template 去做 VMSS + custom image 的部署</p><p><a href="https://github.com/gbowerman/azure-myriad" target="_blank" rel="noopener">https://github.com/gbowerman/azure-myriad</a></p><p>這裡他提供了一個 vmss-linux-customimage.json，點選 deploy to Azure 會發現需要填入一些選項，像是 VM sku 還有 Image 的位置，這邊只要填入剛剛打好的 Custom Image 的位置，就可以作簡單的部署了，而實務上面其實會把改完的 template 利用 Azure CLI 去執行 deploy 。</p><p>不過有一件事情要注意，如果要在其他 region 開這個 custom image，需要將他 copy 到同樣 region 下的 Azure Storage，這點跟 AWS 一樣。</p><h2 id="使用 -Load-Balancer"><a href="# 使用 -Load-Balancer" class="headerlink" title="使用 Load Balancer"></a>使用 Load Balancer</h2><p>當使用的流量上升時，我們會需要使用 Load Balancer 來分流到多個 service，達成 Horizontal Scaling 的需求，用上面提供的 template 也會自動產生 LB 擋在前面，而 VMSS 妙的地方在於需要設定 NAT rule 才能連入裡面的每台 VM，可以參考 Erics 大大的 <a href="https://www.azure-vm.recipes/ch04/dispatch-requests-to-multiple-vms.html" target="_blank" rel="noopener"> 文章</a> 了解一下怎麼設定，接著就可以用 ssh <ip> -p port 去連線，這個跟 AWS 有很大的差別。</ip></p><h3 id="Health-Check"><a href="#Health-Check" class="headerlink" title="Health Check"></a>Health Check</h3><p>跟 AWS 一樣需要設定 Health Check 去確定 Backend service 是不是活著，不過 Portal 介面上面看不到，LB 怎麼判斷後面連到的 VMSS 哪一個 instance 是 Healthy or Unhealthy，這點真的有點讓人覺得討厭。</p><h3 id="LB- 的議題"><a href="#LB- 的議題" class="headerlink" title="LB 的議題"></a>LB 的議題</h3><ul><li>沒辦法知道 Instance Healthy or Unhealthy</li><li>沒辦法更動 Health Check 的 Rule</li><li>沒辦法確定是否有 Connection Draining</li><li>沒辦法設定 Timeout</li><li>能看的 Metrics 太少，或是我在 Portal 中不知道要去哪裡找 (e.g request count, response time, response status)</li><li>不知道怎麼隨便加普通 VM 在某個 LB backend</li><li>不知道 scale in 時能不能 protect 某個 instance 不受影響</li></ul><h1 id="其他"><a href="# 其他" class="headerlink" title="其他"></a>其他 </h1><h2 id="好用的 -debug- 工具"><a href="# 好用的 -debug- 工具" class="headerlink" title="好用的 debug 工具"></a> 好用的 debug 工具 </h2><p> 這個 tool <a href="https://resources.azure.com/" target="_blank" rel="noopener">Azure Resoure Explorer</a> 非常好用，可以讓你直接檢查每個 component 的屬性，而不用一直用 CLI query 其中的狀態，而且有些狀態在 Portal 上面非常難以尋找。</p><h2 id="VMSS- 特點小記"><a href="#VMSS- 特點小記" class="headerlink" title="VMSS 特點小記"></a>VMSS 特點小記 </h2><p> 根據這篇文章記錄一下 <a href="http://www.babylon365.net/got-vm-scale-sets-aka-msazurevmss/" target="_blank" rel="noopener">http://www.babylon365.net/got-vm-scale-sets-aka-msazurevmss/</a></p><ul><li>可以有 Scale in &amp; Scale out 的功能，不過對比 AWS 好像也不是很容易在 Portal 上面設定？</li><li>一個 VMSS 只能有一個 Public IP</li><li>可以設定一個 extension，然後全部的 VM 都 applied 同一個</li><li>支援 Rolling Upgrade</li><li>不 Support Data Disks</li><li>Auto scaling 目前只吃 CPU Metrics?</li><li>沒辦法讓其中的 VM 有 Public IP</li><li>不支援 Disk encryption</li></ul><h2 id="抱怨"><a href="# 抱怨" class="headerlink" title="抱怨"></a>抱怨</h2><ul><li>VM Extension 執行完後，常常 VM 的狀態還是在 Updating 而不是 Complete，最久等過兩個鐘頭才完成，但是 script 早就跑完了…(汗。</li><li>Scale out 機器後，想要 Scale in ，居然沒辦法選擇用什麼 Policy 關機器，而且總是關最新打開的，最後 Rolling upgrade 只好人工寫關閉舊的 VM。</li><li>Portal 少 CLI 太多功能，感覺變得很不實用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在踏入 Azure 領域前，因為原本比較熟悉 AWS，所以從 AWS 的 Service 尋找對應的 Azure Service 算是比較好入門的管道，基本上這個連結 &lt;a href=&quot;https://docs.microsoft.com/zh-tw/azure/archi
      
    
    </summary>
    
    
      <category term="Azure" scheme="http://kkc.github.io/tags/Azure/"/>
    
  </entry>
  
  <entry>
    <title>AWS 四月小聚速記</title>
    <link href="http://kkc.github.io/2017/04/07/aws-group-security-note/"/>
    <id>http://kkc.github.io/2017/04/07/aws-group-security-note/</id>
    <published>2017-04-07T01:48:46.000Z</published>
    <updated>2018-09-09T12:44:49.472Z</updated>
    
    <content type="html"><![CDATA[<p> 這次的聚會是討論 security</p><ol><li>Bastion 機 <ul><li> 外面的 datacenter 都是買現成的 solution，然後有專業的 SI 幫你安裝，感覺很強大啊！</li><li>Tim Hsu 大大分享，他自己建立 bastion 機器，然後利用 container 隔離每個人的登入環境，很容易收集個別帳號在 container 的行為，然後也有寫程式去管理哪些 user 可以連到哪個主機，bastion 機上面也有做 TOTP 加強其安全性。</li><li> 相關的實作方式可以參照 <a href="https://www.slideshare.net/timhsu/docker-honeypot-public" target="_blank" rel="noopener">https://www.slideshare.net/timhsu/docker-honeypot-public</a></li></ul></li><li> 提到如何在外流的 IOT 裝置，如何提升安全性，可以在上面埋一些關卡，像是登入後一定要建立什麼臨時檔案，如果沒有就發出警告出來，或是把 ls, rm 之類的 command 換掉。</li><li> 現在比較流行的是 Bug Bounty ，而不是滲透測試，如果真的要花錢找人做滲透測試，要先自己把該做的地方做一做，而不是無腦請人來攻擊。</li><li> 資訊安全要想到的是，如果真的有洞或是被入侵，要先想好有什麼步驟可以阻斷減少傷害。主機擺在公開網段上就是有可能被攻擊，有點像是潛水艇，真正在出戰的時候，需要很多 sensor 去偵測每個部分是否有問題，真的被打一個洞，要能夠把那邊關掉隔離。</li><li> 如果受到 DDOS 攻擊，在 AWS 上面就是先用 cloud front 去擋擋流量，如果不行就要請上游用 BGP 導去別的地方洗腎 (洗流量)，就是會把髒髒的流量洗掉，聽說中華電信也有洗腎中心，怎麼聽起來也蠻厲害的（大誤 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 這次的聚會是討論 security&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bastion 機 &lt;ul&gt;
&lt;li&gt; 外面的 datacenter 都是買現成的 solution，然後有專業的 SI 幫你安裝，感覺很強大啊！&lt;/li&gt;
&lt;li&gt;Tim Hsu 大大分享，他自己建立 bas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>筆記：學徒模式，優秀軟體開發者的養成之路</title>
    <link href="http://kkc.github.io/2017/02/19/reading-note-apprenticeship-patterns/"/>
    <id>http://kkc.github.io/2017/02/19/reading-note-apprenticeship-patterns/</id>
    <published>2017-02-19T15:40:19.000Z</published>
    <updated>2018-09-09T12:44:49.472Z</updated>
    
    <content type="html"><![CDATA[<p>Note for Apprenticeship patterns: Guidance for the Aspiring Software Craftsman</p><ol><li> 跟專家一起工作，先把語言和工具放一邊，跟著專家學習可以得到最大的成長 </li><li> 為自己安排課程：維護閱讀清單 &amp; 讀完的書，公開自己的清單，也可以從專家那邊獲得不錯的書單 </li><li> 深入知識：深入了解一項技術，了解設計原因而不單是技術細節，掌握工具 GDB, PDB，WireShark 並且願意閱讀規格 <ul><li> 閱讀 RFC 2616:HTTP 1.1 &amp; RFC 707: RPC ，閱讀 Steve Vinoski 有關 RPC 的文章 </li></ul></li><li> 記錄個人所學 &amp; 分享 <ul><li> 勤於寫作 </li></ul></li><li> 建立自己的拋棄式玩具，動手開始做去學 </li><li> 閱讀別人的程式碼 </li><li> 培養自己的熱情，做自己喜歡的事情，並且尋找志趣相同的夥伴 </li><li> 隨時注意自己的學習狀況，若發現自己學習速度減緩或是已經超越身邊其他人，請離開舒適圈 </li><li> 找到適合自己的工具，並正視自己的無知 </li><li>Growth mindset 需要一種信念，相信自己的會變得更好 </li><li> 拓展自己的頻寬 <ul><li> 在推特上面追蹤一些傑出的軟體人員 </li><li> 加入 user group 並提供幫助 </li><li> 說服老闆送你參加研討會，即使不能去，你依然可以閱讀網站上面的簡報檔案 </li><li> 讀完一本書，寄信給作者表達謝意和提問 </li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Note for Apprenticeship patterns: Guidance for the Aspiring Software Craftsman&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 跟專家一起工作，先把語言和工具放一邊，跟著專家學習可以得到最大的成長 &lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="reading" scheme="http://kkc.github.io/tags/reading/"/>
    
  </entry>
  
  <entry>
    <title>How To Use Jenkins Parametered Build</title>
    <link href="http://kkc.github.io/2017/02/13/how-to-use-jenkins-parametered-build/"/>
    <id>http://kkc.github.io/2017/02/13/how-to-use-jenkins-parametered-build/</id>
    <published>2017-02-13T14:31:40.000Z</published>
    <updated>2018-09-09T12:44:49.471Z</updated>
    
    <content type="html"><![CDATA[<p>When we build staging and production environment in Jenkins, we might find out a lot of parts are similar and we just need the variable to switch build. That’s the reason why we need this Jenkins parameterized build plugin. We can use it to define and switch some variables in your build script in order to increase flexibility.</p><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><p>Install the plugin                                                                                                                                                                <a href="https://wiki.jenkins-ci.org/display/JENKINS/Parameterized+Trigger+Plugin" target="_blank" rel="noopener">Parameterized Trigger plugin</a></p><h2 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h2><p>In your project, you need to select <code>This project is parameterized</code><br>                                                                                                                                                                                  <img src="/img/2017-02/parametered_build.png" alt="setting"></p><p>As we can see, Jenkins provides several ways to configure your parameter.<br>for example, we could use <code>Choice Parameter</code></p><p><img src="/img/2017-02/build.png" alt="build"></p><p>Then we could see sidebar has addition option called <code>Build with parameters</code>.<br>Click it and you could see there is a choice for setting the stage.</p><p><img src="/img/2017-02/building.png" alt="building"></p><p>This is a useful skill to manage your project, try to use this plugin to reduce duplicate configurations!</p><p>Ref: <a href="http://ithelp.ithome.com.tw/articles/10187358" target="_blank" rel="noopener">http://ithelp.ithome.com.tw/articles/10187358</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;When we build staging and production environment in Jenkins, we might find out a lot of parts are similar and we just need the variable t
      
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://kkc.github.io/tags/Jenkins/"/>
    
  </entry>
  
</feed>
